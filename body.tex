\section{Introduction}
The \emph{security} of a distributed ledger protocol (DLP) requires that it is both \emph{safe} (the ledger
read by different parties is consistent across time) and \emph{live} (the ledger makes progress
by including honest transactions as time goes by). Safety and liveness are guarantees as
long as one underlying resource remains in honest hands. In proof-of-work systems, this
resource is compute; in proof-of-stake, it is money; and in permissioned systems, it is
honesty by count. If the honest majority assumption fails, all bets are off.
Multiple chains exist in today's ecosystem. It is hard to tell which of them will
maintain their honest majority assumption, and in turn their security, over time.
If we are concerned about the \emph{longevity} of our system, should we run it on top of
Bitcoin, Ethereum, Cardano, Harmony, or some other platform? Surely some of these
systems will remain secure over time, while others will not. Why do we have to make
this choice?

In this paper, we propose \emph{Rollerblade}: A construction of a DLP
that runs on top of other DLPs. If the (weighted)
majority of the underlying DLPs remains secure, the rollerblade running
on top of them also remains secure. Thus, the designer does not need to choose \emph{one}
DLP on which they operate their system, but can express a belief that only a subset of
protocols will survive, even though we do not know which one in particular. Our
construction is generic and can run on top of proof-of-work, proof-of-stake, or
permissioned underlying DLPs, or even a combination thereof.
Additionally, the underlying protocols do not need to be aware that the rollerblade
is running on top of them, and their validator code does not need to be upgraded
to support it. It can be deployed without a hard fork.
Lastly, the rollerblade does not make any additional security
assumptions beyond the security of the (weighted) majority of the underlying
DLPs.

We are therefore making a statement of \emph{reliability}: We are \emph{composing}
different DLPs and building a DLP that enjoys security even if some of them
are faulty.

\noindent
\textbf{Our contributions.} The contributions of this paper are the following:

\begin{enumerate}
  \item We put forth \emph{rollerblade}, the first protocol that achieves DLP
        reliability through composition.
  \item We prove that rollerblade enjoys security if the underlying protocols
        are secure by weighted majority (or $2/3$ majority).
        The weighting is the decision of the rollerblade designer.
  \item We axiomatize our composition so that \emph{any} proof-of-work, proof-of-stake,
        permissioned protocol, or combination thereof, can be used as foundation,
        and any BFT protocol can run on top as the meta-protocol to compose them.
\end{enumerate}

\noindent
\textbf{Related work.} Building a reliable system by composing potentially faulty components
is a classical engineering problem. Von Neumann~\cite{?} composed potentially faulty
resistors to build a fault-tolerant resistor. In the era of consensus, the seminal
paper by Lamport that introduced the Byzantine Fault Tolerance problem~\cite{lamport}
aims to solve a reliability problem, where different processors disagree about their
outcomes. The composition of multiple \emph{blockchain} protocols was explored by
Kiayias et al.~cite{?}, but for the purpose of performance in terms of throughput
and latency, not reliability. The idea of borrowing security from one chain to
secure another was first proposed in the context of \emph{merged mining}~\cite{namecoin}, where
a strong proof-of-work blockchain secures a weaker proof-of-work blockchain. This
concept was later extended to \emph{merged staking}~\cite{pos-sidechains}, where a
strong proof-of-stake \emph{parent chain} lends its security to a less secure
\emph{child chain}. Similar ideas have recently appeared in Cosmos proof-of-stake
chains as \emph{Mesh Security}. Hybrids between different consensus mechanisms
ave also been proposed. The idea of \emph{checkpointing}
one blockchain onto another to borrow security was formalized by Karakostas et al.~\cite{?},
and has been applied to secure newly created proof-of-work systems using stronger
preexisting proof-of-stake systems. All such constructions are uni-directional:
one ``parent'' chain is designated as authoritative and \emph{stronger},
while the ``child'' chain is designated as \emph{weaker} and in need of securing.
Contrary to these constructions, our work aims to create a system in which
no such judgements can be made \emph{a priori}, but all chains are treated
as equal peers in the protocol design. Any chain among these can fail, but
the system must still survive.

\noindent
\textbf{Construction overview.}
The core idea is to checkpoint all underlying DLPs among each other, in
a way that is symmetric and can survive the demise of any minority of the
DLPs.
In a nutshell, rollerblade works by executing any permissioned BFT protocol,
such as Streamlet or HotStuff in a \emph{virtual execution}. This execution is
conducted by the users interested in the protocol (such as the economic stakeholders
in the protocol), who facilitate the protocol's execution by reading and interpreting
the rollerblade-specific transactions written on the underlying ledgers, as well as
posting transactions on the underlying ledgers that cross-checkpoint .

in . At every moment, it is
assumed that at least one honest rollerblade user is online (the
\emph{existential honesty} assumption~\cite{backbone}).
the underlying DLPs are treated as parties.

\section{Model}

\noindent
\textbf{SMT protocol.}
Definition of SMT ...

\noindent
\textbf{Parties running the rollerblade.}
Existential honesty among the parties running the rollerblade...

\noindent
\textbf{Time.}
Time is synchronous...

\section{Construction}

\import{./}{algorithms/alg-rollerblade}
\import{./}{algorithms/alg-majorityvote}
\import{./}{algorithms/alg-relay}
\import{./}{algorithms/alg-view}
\import{./}{algorithms/alg-simulate}
\import{./}{algorithms/alg-encode}
\import{./}{algorithms/alg-ledger}

\section{Analysis}

\begin{definition}[Transcribability]
      Definition of transcribility...
\end{definition}

\begin{definition}[Serializability]
      Definition of serializability...
\end{definition}

\begin{definition}[Soft Determinism]
      Let $\Pi^\Sigma$ be a State Machine Replication protocol that makes
      oracle use of a signature protocol $\Sigma = (\textsf{Gen}, \textsf{Sig}, \textsf{Ver})$.
      The protocol $\Pi$ is called \emph{soft deterministic} if,
      when executed as an interactive turing machine $\Pi^\Sigma(i)$ initialized for party
      with index $i$, the machine does not make use of any local randomness.
\end{definition}

The above definition still allows for use of randomness within the $\Sigma$ protocol of the
signature, which captures the functionality of generating keys, signing, and verifying
messages. Typical BFT protocols such as Streamlet~\cite{streamlet} and Hot Stuff~\cite{hot-stuff}
satisfy the \emph{soft determinism} definition.

\begin{theorem}[Safety]
      Let $\mathcal{L}$ be a weighted set of transcribable Distributed Ledger Protocols,
      and $\Pi$ be a soft-deterministic State Machine Replication protocol.
      Consider a rollerblade constructed with $\Pi$ as a blade and
      $\mathcal{L}$ as its wheels.
      Consider a rollerblade execution in which the weighted majority of $\mathcal{L}$
      is secure.
      Then the rollerblade is safe.
\end{theorem}
\begin{proof}
\end{proof}

\begin{theorem}[Liveness]
      Let $\mathcal{L}$ be a weighted set of transcribable Distributed Ledger Protocols,
      and $\Pi$ be a soft-deterministic State Machine Replication protocol.
      Consider a rollerblade constructed with $\Pi$ as a blade and
      $\mathcal{L}$ as its wheels.
      Consider a rollerblade execution in which the weighted majority of $\mathcal{L}$
      is secure.
      Then the rollerblade is live.
\end{theorem}
\begin{proof}
\end{proof}
