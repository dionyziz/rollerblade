\appsection[Discussion]

\myparagraph[Certificates \textsc{vs} transcriptions]
Our \rollerblade construction was given assuming the underlying protocols
provide a \transcribe and \untranscribe interface which guarantees that
dishonest certificates are always untranscribed into ledgers that are
safe (i.e., the ledger resulting from the untranscription will always
be consistent, albeit not up-to-date, with every other honest party's
ledger across the execution). This requirement is similar to Roughgarden
\emph{et al.}'s notion of \emph{certifiable protocols}~\cite{certifiability}.
However, we can relax this requirement by using mere \emph{transcriptions}
instead of \emph{certificates}. In this case, the \transcribe interface
remains the same and returns a transcription $\tau$. However, \untranscribe
now takes as input multiple transcriptions $\tau_1, \ldots, \tau_n$ and
returns \emph{one} ledger. The \untranscribe function is guaranteed to return
a safe and live ledger as long as \emph{at least one} of the transcriptions
passed into it was recently generated by an honest party. If the \untranscribe
function is invoked with only dishonest transcriptions, no guarantees are
provided. This relaxation allows us to work on top of overlay protocols
which are not certifiable, but only transcribable, such as Nakamoto consensus
(certificates are impossible as chains never adopted by honest parties
can be convincing to a receiver who does not see the current longest chain).

To change the \rollerblade construction to make it work on top of transcribable
underlying protocols is as follows. The data written on the ledger is identical to the
certifiable \rollerblade construction. When the time comes for $\Lambda$ to
\untranscribe, it collects all transcriptions of the past recorded on the ledger.
If a source ledger $i$ ``sends'' a message to destination ledger $i'$, with both
of them being good, the security proof follows through:
Liveness of the receiving ledger guarantees that, every $u_{i'}$ rounds, an honest
transcription of $i$ will be recorded, and thus the untranscribed source ledger
will be safe.

\myparagraph[Practical optimizations]
In our \rollerblade construction, we allowed relayers to freely write all
checkpoints between all pairs of ledgers. This theoretically demonstrates
the breadth of theoretical applicability of our scheme, and highlights
the minimal set of axioms required to build compositors.
However, if such schemes are to be deployed in practice, the relaying
must be optimized. One easy optimization is to have the relayers only
send the \emph{delta} between the previous checkpoint and the current one.
Additionally, if the underlying ledgers provide smart contract
capabilities, one way to do so is to deploy an \emph{on-chain} light
client on each destination chain that consumes data from the source
chain. Such on-chain light clients are already deployed, for example,
in the Cosmos ecosystem~\cite{cosmos} and take the form of IBC
connections~\cite{ibc}. For more details on how to construct this
practically, see TrustBoost~\cite{trustboost}.
