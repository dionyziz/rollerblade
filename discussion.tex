\section{Discussion}

\noindent
\myparagraph[Related work.]
Building a reliable system by composing potentially faulty components
is a classical engineering problem~\cite{von1956probabilistic,moore1956reliable}.
In the era of consensus, the seminal
paper by Lamport that introduced the Byzantine Fault Tolerance problem~\cite{shostak1982byzantine}
aims to solve a reliability problem, where different processors disagree about their
outcomes. The composition of multiple \emph{blockchain} protocols was explored by
\emph{Fitzi et al.}~\cite{combiners}, but for the purpose of performance in terms of
latency, not reliability. In their paper, they also introduce the notion of
\emph{relative persistence}, in which they talk of \emph{dynamic ledgers} (\emph{cf.}, our
\emph{temporal ledgers}) and transaction \emph{ranks} (\emph{cf.}, our \emph{recorded rounds})
which is related, but not equivalent, to our notion of \emph{timeliness}.
They also define the notion of a \emph{blockchain combiner} (\emph{cf.}, our \emph{compositors}).
Their protocol is \emph{passive} (\emph{cf.} TrustBoost~\cite{trustboost}),
meaning the ``combiner'' does not achieve full consensus (\cite[Section 5]{combiners}).
Their ``combiner'' is an instance of our \emph{compositors}, which
further allow for generic distributed protocols to run in an emulated and
replicated fashion, and achieve full consensus.

The idea of borrowing security from one chain to
secure another was first proposed in the context of \emph{merged mining}~\cite{namecoin}, where
a strong proof-of-work (PoW) chain secures a weaker one. This
concept was later extended to \emph{merged staking}~\cite{pos-sidechains}, where a
strong proof-of-stake (PoS) \emph{parent chain} lends security to a less secure
\emph{child chain}. Similar ideas have recently appeared in Cosmos PoS
chains as \emph{Mesh Security}. Hybrids between different consensus mechanisms
have also been proposed. The idea of \emph{checkpointing}
one chain to another to borrow security was formalized by Karakostas et al.~\cite{karakostas2021securing},
and has been applied to secure newly created PoW systems using stronger
preexisting PoS systems. Such constructions are uni-directional:
one ``parent'' chain is designated as authoritative and \emph{stronger},
while the ``child'' chain is designated as \emph{weaker} and in need of securing.
The idea of composing ledgers to achieve a more reliable overlay ledger
was first proposed in a short Cosmos GitHub issue called
\emph{recursive Tendermint}~\cite{recursive-tendermint}.
This concept was expanded upon by TrustBoost~\cite{trustboost}
where they build a composition using Cosmos as the underlying
construction, IBC for cross-chain communication, and Information Theoretic
HotStuff as the overlay protocol. They conjecture that their construction
is secure (short paragraph ``Security guarantee''~\cite[Section 4.1]{trustboost}),
but they leave the proof as an open problem. In the present work, we
answer this open question in the affirmative and calculate the correct
parametrization to instantiate their system securely (e.g., the calculation
of $\Delta$ in Conjecture~\ref{conj:simulation}; we note that an incorrect
choice of $\Delta$ leads to insecure protocol deployments).

\noindent
\myparagraph[Certificates \textsc{vs} transcriptions.]
Our \rollerblade construction was given assuming the underlying protocols
provide a \transcribe and \untranscribe interface which guarantees that
dishonest certificates are always untranscribed into ledgers that are
safe (i.e., the ledger resulting from the untranscription will always
be consistent, albeit not up-to-date, with every other honest party's
ledger across the execution). This requirement is similar to Roughgarden
\emph{et al.}'s notion of \emph{certifiable protocols}~\cite{certifiable-roughgarden}.
However, we can relax this requirement by using mere \emph{transcriptions}
instead of \emph{certificates}. In this case, the \transcribe interface
remains the same and returns a transcription $\tau$. However, \untranscribe
now takes as input multiple transcriptions $\tau_1, \ldots, \tau_n$ and
returns \emph{one} ledger. The \untranscribe function is guaranteed to return
a safe and live ledger as long as \emph{at least one} of the transcriptions
passed into it was recently generated by an honest party. If the \untranscribe
function is invoked with only dishonest transcriptions, no guarantees are
provided. This relaxation allows us to work on top of overlay protocols
which are not certifiable, but only transcribable, such as Nakamoto consensus
(certificates are impossible as chains never adopted by honest parties
can be convincing to a receiver who does not see the current longest chain).

To change the \rollerblade construction to make it work on top of transcribable
underlying protocols is as follows. The data written on the ledger is identical to the
certifiable \rollerblade construction. When the time comes for $\Lambda$ to
\untranscribe, it collects all transcriptions of the past recorded on the ledger.
If a source ledger $i$ ``sends'' a message to destination ledger $i'$, with both
of them being good, the security proof follows through:
Liveness of the receiving ledger guarantees that, every $u_{i'}$ rounds, an honest
transcription of $i$ will be recorded, and thus the untranscribed source ledger
will be safe.

\noindent
\myparagraph[Practical optimizations.]
In our \rollerblade construction, we allowed relayers to freely write all
checkpoints between all pairs of ledgers. This theoretically demonstrates
the breadth of theoretical applicability of our scheme, and highlights
the minimal set of axioms required to build compositors.
However, if such schemes are to be deployed in practice, the relaying
must be optimized. One easy optimization is to have the relayers only
send the \emph{delta} between the previous checkpoint and the current one.
Additionally, if the underlying ledgers provide smart contract
capabilities, one way to do so is to deploy an \emph{on-chain} light
client on each destination chain that consumes data from the source
chain. Such on-chain light clients are already deployed, for example,
in the Cosmos ecosystem~\cite{cosmos} and take the form of IBC
connections~\cite{ibc}. For more details on how to construct this
practically, see TrustBoost~\cite{trustboost}.