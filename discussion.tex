\section{Discussion}

\myparagraph[Related work]
Building reliable systems out of unreliable components
is a classical problem~\cite{von1956probabilistic,moore1956reliable}.
In consensus, Lamport's Byzantine Fault Tolerance problem~\cite{shostak1982byzantine}
aims to solve a reliability problem, where different processors disagree about their
outcomes. The composition of multiple \emph{blockchain} protocols was explored by
\emph{Fitzi et al.}~\cite{combiners}, but for the purpose of performance in terms of
\emph{latency}, not reliability. In their paper, they also introduce the notion of
\emph{relative persistence}, in which they talk of \emph{dynamic ledgers} (\emph{cf.}, our
\emph{temporal ledgers}) and transaction \emph{ranks} (\emph{cf.}, our \emph{recorded rounds})
which is related, but not equivalent, to our notion of \emph{timeliness}.
They also define the notion of a \emph{blockchain combiner} (\emph{cf.}, our \emph{compositors}).
Their protocol is \emph{passive} (\emph{cf.} TrustBoost~\cite{trustboost}),
meaning the ``combiner'' does not achieve full consensus (\cite[Section 5]{combiners}).
Their ``combiner'' is an instance of our \emph{compositors}, which
further allow for generic distributed protocols to run in an emulated and
replicated fashion, and achieve full consensus.

The idea of borrowing security has been explored in \emph{merged mining}~\cite{namecoin},
\emph{merged staking}~\cite{pos-sidechains}, and
\emph{checkpointing}~\cite{karakostas2021securing},
The idea of composing ledgers to achieve a more reliable overlay ledger
was first proposed in a short Cosmos GitHub issue called
\emph{recursive Tendermint}~\cite{recursive-tendermint}.
This concept was expanded upon by TrustBoost~\cite{trustboost}
where they build a composition using Cosmos as the underlying
construction, IBC for cross-chain communication, and Information Theoretic
HotStuff as the overlay protocol. They conjecture that their construction
is secure. However, they stop short of proving the security of their construction.
Their security theorem in the so-called ``active mode'' (\cite[Theorem 2]{trustboost})
states the variable $m$ in the theorem statement. That variable is
interpreted in the \emph{party setting} in the \emph{proof}, but in the \emph{emulated setting}
in the rest of the paper. Therefore, the theorem's positive or negative statement
for $m$ interpreted as ledgers (and not parties) is not proven.
The correspondence between the party setting and the emulated setting is
only conjectured in the short paragraph ``Security guarantee''~\cite[Section 4.1]{trustboost}.
Proving this correspondence requires significant technical work and the framework
which we develop in this paper.
In the present work, we
answer the question TrustBoost left open affirmative and calculate the correct
parametrization to instantiate their system securely (e.g., the calculation
of $\Delta$ in Conjecture~\ref{conj:emulation}). We note that any secure
deployment of TrustBoost must include a correct choice of the parameter $\Delta$,
whose calculation is missing from their paper.

\myparagraph[Certificates \textsc{vs} transcriptions]
Our \rollerblade construction was given assuming the underlying protocols
provide a \transcribe and \untranscribe interface which guarantees that
dishonest certificates are always untranscribed into ledgers that are
safe (i.e., the ledger resulting from the untranscription will always
be consistent, albeit not up-to-date, with every other honest party's
ledger across the execution). This requirement is similar to Roughgarden
\emph{et al.}'s notion of \emph{certifiable protocols}~\cite{certifiable-roughgarden}.
However, we can relax this requirement by using mere \emph{transcriptions}
instead of \emph{certificates}. In this case, the \transcribe interface
remains the same and returns a transcription $\tau$. However, \untranscribe
now takes as input multiple transcriptions $\tau_1, \ldots, \tau_n$ and
returns \emph{one} ledger. The \untranscribe function is guaranteed to return
a safe and live ledger as long as \emph{at least one} of the transcriptions
passed into it was recently generated by an honest party. If the \untranscribe
function is invoked with only dishonest transcriptions, no guarantees are
provided. This relaxation allows us to work on top of overlay protocols
which are not certifiable, but only transcribable, such as Nakamoto consensus
(certificates are impossible as chains never adopted by honest parties
can be convincing to a receiver who does not see the current longest chain).

To change the \rollerblade construction to make it work on top of transcribable
underlying protocols is as follows. The data written on the ledger is identical to the
certifiable \rollerblade construction. When the time comes for $\Lambda$ to
\untranscribe, it collects all transcriptions of the past recorded on the ledger.
If a source ledger $i$ ``sends'' a message to destination ledger $i'$, with both
of them being good, the security proof follows through:
Liveness of the receiving ledger guarantees that, every $u_{i'}$ rounds, an honest
transcription of $i$ will be recorded, and thus the untranscribed source ledger
will be safe.

\myparagraph[Practical optimizations]
In our \rollerblade construction, we allowed relayers to freely write all
checkpoints between all pairs of ledgers. This theoretically demonstrates
the breadth of theoretical applicability of our scheme, and highlights
the minimal set of axioms required to build compositors.
However, if such schemes are to be deployed in practice, the relaying
must be optimized. One easy optimization is to have the relayers only
send the \emph{delta} between the previous checkpoint and the current one.
Additionally, if the underlying ledgers provide smart contract
capabilities, one way to do so is to deploy an \emph{on-chain} light
client on each destination chain that consumes data from the source
chain. Such on-chain light clients are already deployed, for example,
in the Cosmos ecosystem~\cite{cosmos} and take the form of IBC
connections~\cite{ibc}. For more details on how to construct this
practically, see TrustBoost~\cite{trustboost}.
