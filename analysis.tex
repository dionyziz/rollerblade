\section{Analysis}

% \begin{definition}[Determinism]
%       Let $\Pi^\Sigma$ be a State Machine Replication protocol that makes
%       oracle use of a signature protocol $\Sigma = (\textsf{Gen}, \textsf{Sig}, \textsf{Ver})$.
%       The protocol $\Pi$ is called \emph{soft deterministic} if,
%       when executed as an interactive turing machine $\Pi^\Sigma(i)$ initialized for party
%       with index $i$, the machine does not make use of any local randomness.
% \end{definition}
%
% TODO: define underlying, overlay, good, VIEW...

\begin{definition}[Lateness]
\end{definition}

\begin{definition}[Exec]
\end{definition}

\begin{definition}[View]
\end{definition}

% TODO: Move this to definitions? Expand this intuitive explanation,
% and give it a title
% Potential generalization: Use a different H_Z and H_Y that indicate
% which Ys are "good" and which Zs are supposed to be "honest", and
% make H_Z a function of H_Y, to be defined by the DPCP.
% This would allow having a different number of Zs and Ys,
% and each of the Zs could depend on different, and potentially multiple, Ys;
% and each Y could help multiple Zs.

A Distributed Protocol Composition Protocol (DPCP) is a protocol that
runs an \emph{overlay} distributed protocol $\Pi$ on top of a set of
$n$ \emph{underlying} distributed protocols $\Y[][1], \ldots, \Y[][i], \ldots, \Y[][n]$.
The protocol $\Pi$ is generally designed
to work in the \emph{party setting} with a network (such as an authenticated channels network)
connecting its instances directly.
The DPCP executes
$\Pi$ in the \emph{emulated setting} by utilizing the underlying
$\Y[][i]$ protocols to help with the emulation and communication between the
overlay protocol instances.
Multiple instances $\Lambda_1, \ldots, \Lambda_j, \ldots, \Lambda_m$
of DPCP are executed.
Each $j^\text{th}$ DPCP instance promises to emulate the execution of multiple
instances of $\Pi$ ($\Z[j][1], \ldots, \Z[j][i], \ldots \Z[j][n]$).
These emulated $\Z$ instances should behave similarly to instances of $\Pi$
running in a stand-alone setting.

\begin{definition}[Distributed Protocol Composition Protocol]
  A Distributed Protocol Composition Protocol (DPCP) family
  is a family of interactive machines
  $\Lambda_{\Pi,(\Y[][1], \ldots, \Y[][n])}$ providing the following
  functionalities:

  \begin{enumerate}
    \item \textbf{construct}$(\sid, j)$.
    \item \textbf{writeToMachine}$(i, \data)$.
    \item \textbf{emulateMachine}$(i, r)$. % <-- Z
  \end{enumerate}
\end{definition}

The DPCP is constructed by calling \emph{construct} with parameters the session identifier $\sid$
and the DPCP instance identity $j \in \mathbb{N}$. Each DPCP instance provides a \emph{writeToMachine}
functionality that allows writing data to the $i^\text{th}$ emulated machine.
It also provides an \emph{emulateMachine} functionality that promises to emulate the execution of
the $i^\text{th}$ instance of $\Pi$ up to round $r$, and return the transcript of this emulation
and the instance of this emulation.

Even though we will not do the analysis in the full Universal Composability (UC) framework, and
we treat executions as stand-alone, we do adopt some of the notation of the UC framework.
Let $\LCExec(\Lambda, \Pi, ({\Y[][1]}, \cdots, {\Y[][n]}), \mathcal{A}, \mathcal{Z}, \mathcal{H})$
denote the transcript of an execution of the DPCP protocol $\Lambda$ parametrized with overlay protocol $\Pi$,
and underlying protocols $\Y[][1], \ldots, \Y[][n]$, adversary $\mathcal{A}$, environment $\mathcal{Z}$,
indices of honest parties $\mathcal{H}$.
Following the notation of the UC framework, we define the notion of an \emph{execution}
and a \emph{view}... % TODO(tzinas/dionyziz)... define these.

% TODO: Define belief system and honesty correspondence
We are now ready to define the notion of \emph{faithfulness} of a
Distributed Protocol Composition Protocol (DPCP), which captures the
correspondence between the party setting execution and the emulated setting
execution of $\Pi$. Roughly, a DPCP is called \emph{faithful} is these
two settings are identical in the eyes of the honest parties.
This faithfulness may be conditioned to work only on certain classes
of overlay protocols $\Pi$ and underlying protocols $\Y$, and may
require that a certain subset $\mathcal{H}$ of these $\Y$s are well-behaved.
This good-behavior is captured by the notion of a \emph{goodness} predicate $Q$.

% TODO: Mention that the validator and other protocol settings for \Y[][i]
% are hard-coded into \Y[][i]
\begin{definition}[Distributed Protocol Composition Faithfulness]
  A DPCP $\Lambda$
  is $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful}
  for an overlay protocol $\Pi$,
  a number of overlay parties $n \in \mathbb{N}$,
  a sequence of underlying protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  a belief system $\mathcal{B}$,
  honesty correspondence $\mathcal{H}: \mathcal{B} \longrightarrow 2^{[n]}$,
  and delay $\Delta \in \mathbb{N}$ if:

  For all beliefs $B \in \mathcal{B}$,
  for all PPT adversaries $\mathcal{A}$ and all PPT environments $\mathcal{Z}$,
  % TODO: There is no need for the polynomiality constraint on A and Z,
  % but the reduction maintains polynomiality
  there is a PPT simulator $\mathcal{S}$ and there is a
  PPT environment $\mathcal{Z}'$ such that following holds:

  \begin{enumerate}
    \item $\LCView(\mathcal{E}) \distreq \PEView(\mathcal{E}')$
    \item $\LCExtern(\mathcal{E}) \latedistr{\Delta} \PEExtern(\mathcal{E}')$
  \end{enumerate}

  where execution $\mathcal{E}$ is sampled from
  % TODO: Do not use "EXEC", as this is inconsistent with the UC framework
  $\LCExec(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$
  % TODO: B should only depend on the collective execution of \Y, not anything else
  conditioned on the belief $B(\mathcal{E})$,
  and execution $\mathcal{E}'$ is sampled from

  \[
  \PEExec(\Pi, \mathcal{S}, \mathcal{Z}', n, \mathcal{H}(B), \Delta)\,.
  \]
\end{definition}

% Remark: Differences from a UC-style proof

\begin{lemma}[Past Perfect]
  Consider a temporal ledger protocol $\Y$
  constrained to report ledgers in which each transaction appears at most once.
  Consider an execution $\Exec$ with duration $R$ rounds in which $\Y$ is
  safe, live with liveness $u$, timely with timeliness $v$.
  If for some honest party $P_1$ and some round $r_1$ it holds that
  $(r^*, \tx) \in \Ledger[P_1][][r_1]$, then
  for all honest parties $P_2$ and for all rounds $r^* + v < r_2 < R - u - 1$
  it holds that
  $(r^*, \tx) \in \Ledger[P_2][][r_2]$,
  % TODO:
  % We may be able to remove this extra assumption if
  % we change temporal ledgers to also report their "current time"
  % under the following constraints:
  % 1) In synchronous settings, or after GST in psync, the "current time"
  %    reported by the ledger must not be too far in the past (more than $v$?)
  % 2) The "current time" reported must march only forward;
  %    the next "current time" reported must be larger than the
  %    current "current time" reported.
  % 3) If I read the ledger at some round r_1 and the current time reported
  %    is r_1', then I read the ledger again at round r_2 > r_1, then
  %    any *new* transactions that appear must have a recorded round of
  %    at least r_1'.
  % We may be able to replace "timeliness" completely with the above
  % definition.
  as long as at least one new honest transaction $\tx'$ appears at
  any round $r_3 > r_2$.
\end{lemma}
\begin{proof}
  Consider an execution as in the statement and suppose, towards a contradiction,
  that $(r^*, \tx) = \Ledger[P_1][][r_1][k]$ for some $k \in \mathbb{N}$
  with $r^* + v < r_2$, but
  $(r^*, \tx) \not\in \Ledger[P_2][][r_2]$.
  Due to liveness,
  $(*, \tx') = \Ledger[P_1][][r_3 + u][k']$ for some $k' \in \mathbb{N}$.
  As $\tx'$ is new, it is not in $\Ledger[P_1][][r_1]$.
  Because the ledger is safe, $k' > k$.
  Due to liveness, $(*, \tx') \in \Ledger[P_2][][r_3 + u]$.
  Due to safety, $(*, \tx') = \Ledger[P_2][][r_3 + u][k']$.
  Therefore, $|\Ledger[P_2][][r_3 + u]| \geq k$.
  Due to safety, $\Ledger[P_2][][r_3 + u][k] = (r^*, \tx)$.
  Because $\Ledger[P_2][][r_3 + u]$ has a transaction
  that $\Ledger[P_2][][r_2]$ does not have (namely $\tx$)
  and it is safe, therefore
  $(r^*, \tx) \in \Ledger[P_2][][r_3 + u][|\Ledger[P_2][][r_2]|{:}]$.
  Since $r^* < r_2 - v$, this contradicts the timeliness with parameter $v$.\qed
\end{proof}

The above property, which follows from safety, liveness, timeliness and
contiguous honest participation is also known in the literature as
\emph{persistence}~\cite{backbone}.

% TODO: define rollerblade belief system and honesty correspondence
\begin{definition}[Rollerblade Belief System]
  Given a sequence of \rollerblade-underlying-respecting
  protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  define for each $i \in [\ell]$ the following predicate on
  a collective execution $\mathcal{E}$ of $\mathcal{Y}$:

  \[
    \text{good}_i(\mathcal{E}) = \text{``} \Y[][i] \text{ is safe, live$(u_i)$, and timely$(v_i)$ in $\mathcal{E}$''}
  \]

  Then, the \rollerblade belief system $\mathcal{B}$ of $\mathcal{Y}$
  is the powerset of the set

  \[
    \{ \text{good}_i: \Y[][i] \in \mathcal{Y} \}
  \]
\end{definition}

% TODO: Define the relationship between Z and Z';
%       we are hoping that Z' will have exactly the same writes as Z
%       (perhaps more due to adversarial writes) for each party
%       and that those will appear in "close enough" times (maybe up to $u$ away
%       from the original)
\begin{conjecture}[Rollerblade Simulation]\label{conj:simulation}
  For all protocols $\Pi$ that are \rollerblade-overlay-respecting,
  and any sequence of protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$
  that are \rollerblade-underlying-respecting,
  for the \rollerblade-belief-system $\mathcal{B}$ of $\mathcal{Y}$
  and respective honesty correspondence $\mathcal{H}$,
  the \rollerblade construction $\Lambda$ of Section~\ref{sec:construction} is
  $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful}.
  where $n = |\mathcal{Y}|$, $\Delta = \max\{u_i\}_{i \in [n]}$,
  and $u_i$ is the promised liveness of $\Y[][i]$.
\end{conjecture}

\begin{conjecture}[Cross-party]\label{conj:cross-party}
  Consider an \rollerblade execution with $n \in \mathbb{N}$ underlying
  and $m \in \mathbb{N}$ overlay parties.
  For all rounds $r$, all overlay parties $\RB[j], \RB[j']$,
  and all underlying $i \in \mathbb{N}$:

  \[
    \Sim[j][r](i, r - v_i, r) = \Sim[j][r](i, r - v_i, r)
  \]
\end{conjecture}

% TODO: Consider the case of "written communication", or "transferable origin" constructions
% \begin{definition}[Authenticated Communication Protocol]
%       An Authenticated Communication Protocol ACP is...
%       Define what is the syntax of $\Sigma$... (and maybe use a different letter)
%       ... TODO
% \end{definition}
% \begin{definition}[Peer-to-Peer ACP]
%       Make an ACP by composing an existentially unforgeable signature scheme and
%       a synchronous network... TODO
% \end{definition}
% The above definition still allows for use of randomness within the $\Sigma$ protocol of the
% signature, which captures the functionality of generating keys, signing, and verifying
% messages. Typical BFT protocols such as Streamlet~\cite{streamlet} and Hot Stuff~\cite{hotstuff}
% satisfy the \emph{soft determinism} definition.