\section{Analysis}

To aid the analysis, we assume that the ITIs contain all the previous transcript
of their execution (a history of machine configurations).

% \begin{definition}[Determinism]
%       Let $\Pi^\Sigma$ be a State Machine Replication protocol that makes
%       oracle use of a signature protocol $\Sigma = (\textsf{Gen}, \textsf{Sig}, \textsf{Ver})$.
%       The protocol $\Pi$ is called \emph{soft deterministic} if,
%       when executed as an interactive turing machine $\Pi^\Sigma(i)$ initialized for party
%       with index $i$, the machine does not make use of any local randomness.
% \end{definition}
%
% TODO: define underlying, overlay, good, VIEW...

% TODO: Move this to definitions? Expand this intuitive explanation,
% and give it a title
% Potential generalization: Use a different H_Z and H_Y that indicate
% which Ys are "good" and which Zs are supposed to be "honest", and
% make H_Z a function of H_Y, to be defined by the DPCP.
% This would allow having a different number of Zs and Ys,
% and each of the Zs could depend on different, and potentially multiple, Ys;
% and each Y could help multiple Zs.

A \emph{compositor} is a protocol that
runs an \emph{overlay} distributed protocol $\Pi$ on top of a set of
$n$ \emph{underlying} distributed protocols $\Y[][1], \ldots, \Y[][i], \ldots, \Y[][n]$.
The protocol $\Pi$ is generally designed
to work in the \emph{party setting} with a network (such as an authenticated channels network)
connecting its instances directly.
The compositor $\Lambda$ executes
$\Pi$ in the \emph{emulated setting} by utilizing the underlying
$\Y[][i]$ protocols to help with the emulation and communication between the
overlay protocol instances.
Multiple instances $\LLambda[1], \ldots, \LLambda[j], \ldots, \LLambda[m]$
of the compositor are executed.
Each $j^\text{th}$ compositor instance promises to emulate the execution of multiple
instances of $\Pi$ ($\Z[j][1], \ldots, \Z[j][i], \ldots \Z[j][n]$).
These emulated $\Z$ instances should behave similarly to instances of $\Pi$
running in a stand-alone setting.

\begin{definition}[Compositor]
  A \emph{compositor} $\Lambda$ with overlay $\Pi$ and underlying $\mathcal{Y} = \Y[][1], \ldots, \Y[][n]$,
  is a family of interactive machines
  $\Lambda_{\Pi,\mathcal{Y}}$ providing the following
  functionalities:

  \begin{enumerate}
    \item \construct$(\sid, (\Y[j][1] \ldots \Y[j][n]))$.
    \item \writeToMachine$(i, \data)$.
    \item \emulateMachine$(i, r)$. % <-- Z
  \end{enumerate}
\end{definition}

The compositor is constructed by calling \emph{\construct} with parameter the session identifier $\sid$.
Note that compositors are permissionless, as they don't know their instance identity $j \in \mathbb{N}$.
Each compositor instance provides a \emph{\writeToMachine}
functionality that allows writing data to the $i^\text{th}$ emulated machine.
It also provides an \emph{\emulateMachine} functionality that promises to emulate the execution of
the $i^\text{th}$ instance of $\Pi$ up to round $r$, and return the instance of this emulation
at round $r$ (and note that this contains the full transcript of the emulation).
Observe that \emph{\emulateMachine} can be invoked at a later round $r' > r$.
Note here the difference between $\mathcal{Y} = \Y[][1], \ldots, \Y[][n]$ (denoting \emph{underlying protocols}
in the form of ITMs) and
$(\Y[j][1], \ldots, \Y[j][n])$ (denoting \emph{underlying protocol instances}
in the form of ITIs). The compositor is parametrized with the former, and
the latter are passed as parameters to the \emph{\construct} functionality.

Even though we will not do the analysis in the full Universal Composability (UC) framework, and
we treat executions as stand-alone, we do adopt some of the notation of the UC framework.
Let $\LCExec(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$
denote the transcript of an execution of the compositor protocol $\Lambda$ parametrized with overlay protocol $\Pi$,
and underlying protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][n])$, adversary $\mathcal{A}$, and environment $\mathcal{Z}$.
Following the notation of the UC framework, we define the notion of an \emph{execution}
and a \emph{view}.

\noindent
\textbf{The Emulated Setting.}
In particular, in the emulated setting execution, denoted by $\LCExec_{m,n}(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$,
the environment $\mathcal{Z}$ is constrained by the control program
to initially
spawn a number $n \times \ell$ (where $n$ is a parameter of the execution,
and $\ell = |\mathcal{Y}|$)
underlying protocol instances

\begin{align*}
\Y[1][1], \Y[1][2], &\ldots, \Y[1][\ell],\\
\Y[2][1], \Y[2][2], &\ldots, \Y[1][\ell],\\
                    &\vdots              \\
\Y[m][1], \Y[m][2], &\ldots, \Y[m][\ell]\,,
\end{align*}

where $\Y[j][i]$ denotes the $j^\text{th}$ instance of
the protocol $\Y[][i]$. The environment facilitates the communication
between the underlying protocol instances $\Y[j][i]$ and $\Y[j'][i]$
for all $j, j'$, whereas protocols $\Y[j][i]$ and $\Y[j'][i']$
with $i \neq i'$ are not allowed to directly communicate.
Next, the environment is constrained to spawn
a number $m$ of compositor clients
$\LLambda[1], \ldots, \LLambda[m]$ (where $m \in \mathbb{N}$
is a parameter of the execution), allowing
the environment to choose the $\sid$ parameter,
and passing the tuple $(\Y[j][1], \ldots, \Y[j][\ell])$ of ITIs
to $\LLambda[j]$'s \emph{construct} functionality
(in UC language, each of these $\Y[j][i]$ is constrained to be used
as a \emph{subroutine} solely by $\LLambda[j]$).
The execution proceeds in rounds $r = 1, \ldots, R$
for a polynomial number $R$ of rounds (where the polynomial
is taken with respect to the security parameter). For every
round $r$, the environment is constrained to first call
the \emph{execute} function of each $\Y[j][i]$ for every
$j, i \in \mathbb{N}$. Next, the environment must call
the \emph{execute} function of each $\LLambda[j]$ sequentially.
Finally, the environment is constrained to call the
adversary $\mathcal{Z}$ (a rushing adversary).
At any time, the environment may choose to provide inputs
to any of the $\LLambda[j]$ parties by invoking their \emph{writeToMachine}
functionality with inputs of its choice.

\noindent
\textbf{The Party Setting.}
In the party setting execution, denoted by $\PEExec_n(\Pi, \mathcal{A}, \mathcal{Z}, n, H, \Delta)$,
the environment $\mathcal{Z}$ is constrained by the control program
to spawn $n$ parties $\PPi[1], \ldots, \PPi[n]$ (where $n \in \mathbb{N}$
is a parameter of the execution). Note here that $\Pi$ is a protocol (an ITM),
whereas each $\PPi[i]$ is an instance (an ITI).
The adversary $\mathcal{A}$ is allowed to corrupt parties
indexed by $[n] \setminus H$ at the beginning of the execution
(a static corruption model). This is done by the adversary sending a message
to the environment requesting to corrupt the desired party. The environment
grants this corruption wish as long as it respects the requirement that the
corruption falls within $[n] \setminus H$.
The execution proceeds in rounds
$r = 1, \ldots, R$, where $R$, again, is a polynomial of the security
parameter. At every round, the environment is constrained to first
call the \emph{execute} function of each $\PPi[i]$ for every
honest party, in order. Next, the environment must call
the adversary (again, a rushing adversary). The environment
is constrained to deliver messages between honest parties
in an authenticated manner, and to deliver messages within $\Delta$
delay.

We define the following views for the two execution settings.

\begin{definition}[Honest View in the Party Setting]
  Consider a party setting execution $\mathcal{E}'$ sampled from
  $\PEExec_n(\Pi, \mathcal{A}, \mathcal{Z}, n, H, \Delta)$.
  The \emph{party setting view of honest parties} $\PEView_H(\mathcal{E}')$
  is the $|H|\times R$ matrix of the following transcripts of honest parties:

  \[
  \begin{bmatrix}
    \PPi[H_1]_1 &\ldots& \PPi[H_1]_R\\
         \vdots &\ddots& \vdots     \\
    \PPi[H_{|H|}]_1 &\ldots& \PPi[H_{|H|}]_R
  \end{bmatrix}\,,
  \]

  where $\PPi[H_i]_r$ denotes the transcript of party $\PPi[H_i]$
  (the party with index $H_i$, the $i^\text{th}$ honest party)
  obtained at round $r$.
\end{definition}

Note that, in the above definition, the transcripts concerned pertain to the
set $H$ of guaranteed honest party indices only, even though the adversary may choose
to leave some of the other parties uncorrupted, too. The transcript of
those other parties are not included in $\PEView_H(\mathcal{E}')$.

Note also that, in each row of the above definition, the transcripts
are taken for a particular party $H_i$ at increasing rounds, and therefore
we will have that $\PPi[H_i]_r \preceq \PPi[H_i]_{r+1}$ and, so, the transcripts
recorded in each row will be growing in an append-only fashion.

\begin{definition}[Emulation Consistency]
  An execution $\mathcal{E}$ with duration $R$ rounds sampled from
  $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$
  is \emph{$(j,H,\Delta_v)$-\emph{consistent}} if
  for all $i \in H$, for all $r \geq 1$,
  for all $r + \Delta_v < r' < R$,
  it holds that
  $\LLambda[j].\emulateMachine(i, r)$ executed \emph{in vitro} after round $r'$
  is equal to
  $\LLambda[j].\emulateMachine(i, r)$ executed \emph{in vitro} after round $r' + 1$.
\end{definition}

\begin{definition}[Honest View in the Emulated Setting]
  Consider an emulated setting execution $\mathcal{E}$ with duration $R$ rounds
  sampled from $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$.
  If the execution $\mathcal{E}$ is $(j,H,\Delta_v)$-consistent, then
  the \emph{emulated setting view of honest parties} $\LCView_{j,H,\Delta_v}(\mathcal{E})$,
  % TODO: change "reality lag" to be a generic "time distortion" function,
  % for now f(r) = r + \Delta_v, but this could be more generic
  parametrized by an index $j$, a set of indices $H$, and a \emph{reality lag} $\Delta_v \in \mathbb{N}$,
  is the $|H| \times R$ matrix of the following values:

  \[
  \begin{bmatrix}
    \LLambda[j].\emulateMachine(H_1, 1) & \ldots & \LLambda[j].\emulateMachine(H_1, R - \Delta_v - 1)\\
                                 \vdots & \ddots & \vdots \\
    \LLambda[j].\emulateMachine(H_{|H|}, 1) & \ldots & \LLambda[j].\emulateMachine(H_{|H|}, R - \Delta_v - 1)
  \end{bmatrix}\,,
  \]

  where $\LLambda[j].\emulateMachine(H_i, r)$ denotes the return value of invoking,
  \emph{in vitro} after round $r + \Delta_v + 1$,
  the $\emulateMachine$ functionality of the $j^\text{th}$ compositor party $\LLambda[j]$
  with parameters the index $H_i$ of the $i^\text{th}$ overlay machine (among those
  included in $H$) and round $r$.

  On the other hand, if the execution $\mathcal{E}$ is \emph{not} $(j,H,\Delta_v)$-consistent, then
  we let $\LCView_{j,H,\Delta_v}(\mathcal{E}) = \bot$.
\end{definition}

\begin{definition}[Lateness]
\end{definition}

% TODO(tzinas/dionyziz)... define these.
% Define how the environment Z and the environment Z' functions step by step
% e.g., the environment Z is given $m$ compositor parties to spin up
% and both environments must orchestrate the execution in a lockstep manner

% TODO: Define belief system and honesty correspondence
% TODO: Define a belief-respecting environment
We are now ready to define the notion of \emph{faithfulness} of a
compositor, which captures the
correspondence between the party setting execution and the emulated setting
execution of $\Pi$. Roughly, a compositor is called \emph{faithful} is these
two settings are identical in the eyes of the honest parties.
This faithfulness may be conditioned to work only on certain classes
of overlay protocols $\Pi$ and underlying protocols $\Y$, and may
require that a certain subset $\mathcal{H}$ of these $\Y$s are well-behaved.
This good-behavior is captured by the notion of a \emph{goodness} predicate $Q$.

% TODO: Mention that the validator and other protocol settings for \Y[][i]
% are hard-coded into \Y[][i]
\begin{definition}[Compositor Faithfulness]
  A compositor $\Lambda$
  is $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful}
  for an overlay protocol $\Pi$,
  a number of overlay parties $n \in \mathbb{N}$,
  a sequence of underlying protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  a belief system $\mathcal{B}$,
  honesty correspondence $\mathcal{H}: \mathcal{B} \longrightarrow 2^{[n]}$,
  and delay $\Delta \in \mathbb{N}$ if:

  For all beliefs $B \in \mathcal{B}$,
  for all PPT adversaries $\mathcal{A}$ and all
  $B$-respecting PPT environments $\mathcal{Z}$,
  for all number of compositor parties $m \in \mathbb{N}$,
  for all compositor party indices $j \in [m]$,
  % TODO: There is no need for the polynomiality constraint on A and Z,
  % but the reduction maintains polynomiality
  there is a PPT simulator $\mathcal{S}$ and there is a
  PPT environment $\mathcal{Z}'$ such that
  the following holds:

  \begin{enumerate}
    \item $\LCView_{j,\mathcal{H}(B)}(\mathcal{E}) \distreq \PEView_{\mathcal{H}(B)}(\mathcal{E}')$
    \item $\LCExtern_{j,\mathcal{H}(B)}(\mathcal{E}) \latedistr{\Delta} \PEExtern_{\mathcal{H}(B)}(\mathcal{E}')$
  \end{enumerate}

  where execution $\mathcal{E}$ is sampled from
  % TODO: Do not use "EXEC", as this is inconsistent with the UC framework
  $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$
  % TODO: B should only depend on the collective execution of \Y, not anything else
  and execution $\mathcal{E}'$ is sampled from
  $\PEExec(\Pi, \mathcal{S}, \mathcal{Z}', n, \mathcal{H}(B), \Delta)$.
\end{definition}

% Remark: Differences from a UC-style proof

\begin{lemma}[Past Perfect]\label{lem:past-perfect}
  Consider a temporal ledger protocol $\Y$'s
  execution $\Exec$ with duration $R$ rounds in which $\Y$ is
  safe, live with liveness $u$, and timely with timeliness $v$.
  If for some honest party $P_1$ and some round $r_1$ it holds that
  $(r^*, \tx) \in \Ledger[P_1][][r_1]$, then
  for all honest parties $P_2$ and for all rounds $r_2 > r^* + v$
  it holds that
  $(r^*, \tx) \in \Ledger[P_2][][r_2]$,
  % TODO:
  % We may be able to remove this extra assumption if
  % we change temporal ledgers to also report their "current time"
  % under the following constraints:
  % 1) In synchronous settings, or after GST in psync, the "current time"
  %    reported by the ledger must not be too far in the past (more than $v$?)
  % 2) The "current time" reported must march only forward;
  %    the next "current time" reported must be larger than the
  %    current "current time" reported.
  % 3) If I read the ledger at some round r_1 and the current time reported
  %    is r_1', then I read the ledger again at round r_2 > r_1, then
  %    any *new* transactions that appear must have a recorded round of
  %    at least r_1'.
  % We may be able to replace "timeliness" completely with the above
  % definition.
  as long as at least one new honest transaction $\tx'$ appears at
  any round $r_1 < r_3 \leq R - u$.
\end{lemma}
\begin{proof}
  Consider an execution as in the statement and suppose, towards a contradiction,
  that $(r^*, \tx) = \Ledger[P_1][][r_1][k]$ for some $k \in \mathbb{N}$,
  but $(r^*, \tx) \not\in \Ledger[P_2][][r_2]$
  with $r^* + v < r_2$.
  From safety,
  $\Ledger[P_2][][r_2] \prec \Ledger[P_1][][r_1]$ and
  $|\Ledger[P_2][][r_2]| \leq k < |\Ledger[P_1][][r_1]|$.
  Due to liveness, $(r', \tx') = \Ledger[P_2][][r_3 + u][k']$,
  for some $r', k' \in \mathbb{N}$.
  As $\tx'$ is new, it is not in $\Ledger[P_1][][r_1]$.
  Due to safety, $k' \geq |\Ledger[P_1][][r_1]| > k$.
  Due to safety, $\Ledger[P_2][][r_3 + u][k] = (r^*, \tx)$.
  Therefore
  $(r^*, \tx) \in \Ledger[P_2][][r_3 + u][|\Ledger[P_2][][r_2]|{:}]$.
  Since $r^* < r_2 - v$, this contradicts the timeliness with parameter $v$.\qed
\end{proof}

The above property, which follows from safety, liveness, timeliness and
contiguous honest participation is also known in the literature as
\emph{persistence}~\cite{backbone}.

\begin{definition}[Rollerblade Belief System and Honesty Correspondence]
  Given a sequence of \rollerblade-underlying-respecting
  protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  define for each $i \in [\ell]$ the following predicate on
  a collective execution $\mathcal{E}$ of $\mathcal{Y}$:

  \[
    \text{good}_i(\mathcal{E}) = \text{``} \Y[][i] \text{ is safe, live$(u_i)$, and timely$(v_i)$ in $\mathcal{E}$''}
  \]

  Define $\mathcal{H}^{-1}$ on the domain $2^{[n]}$ as
  $\mathcal{H}^{-1}(H) = \bigwedge_{i \subseteq H} \text{good}_i$.
  Then the \emph{\rollerblade honesty correspondence $\mathcal{H}$ of $\mathcal{Y}$}
  is the inverse of $\mathcal{H}^{-1}$ and the \emph{\rollerblade belief system
  $\mathcal{B}$ of $\mathcal{Y}$} is the domain of $\mathcal{H}$.
\end{definition}

\begin{lemma}[Rollerblade Cross-party]\label{lem:cross-party}
  Consider a \rollerblade execution $\mathcal{E}$ with duration $R$ rounds
  with $n \in \mathbb{N}$ underlying
  and $m \in \mathbb{N}$ compositor parties.
  For
  all underlying indexes $i \in [n]$ such that $\text{good}_i(\mathcal{E})$,
  all rounds $1 \leq r < R - \max(v_i, u_i)$,
  and
  all compositor party indexes $j, j' \in [m]$

  \[
    \Sim[j][r] = \Sim[j'][r]\,,
  \]

  where $\Sim[j][r]$ (resp. $\Sim[j'][r]$) indicates the result of calling
  \emulateMachine of $\RB[j]$ (resp. $\RB[j']$) with inputs
  $(i, r, r + v_i)$
  at the end of round $r + v_i$.
\end{lemma}
\begin{proof}
  The function \emulateMachine of party $j$ (resp. party $j'$)
  calls the deterministic function \simulate with overlay party index $i$,
  ledger $\Ledger[j][i][r + v_i]$ (resp. ledger $\Ledger[j'][i][r + v_i]$), simulation round
  $r$, and current round $r + v_i$. The function \simulate runs its main
  \emph{for} loop (Algorithm~\ref{alg.simulate} Line~\ref{alg.simulate:for})
  up to $r$ (inclusive), which consumes data from $\writeboxes[r - 1]$
  and $\inboxes[r - 1]$ and earlier. These are produced by the function
  \prepareSimulationInputs by looking at transactions recorded in $\Ledger[j][i][r + v_i]$
  (resp. $\Ledger[j'][i][r + v_i]$) with recorded round $< r$.
  Because $\Ledger[][i]$ is \emph{good} in $\mathcal{E}$, it is safe, live($u_i$), and timely($v_i$).
  It suffices to show that all transactions with recorded round
  $< r$ are the same in $\Ledger[j][i][r + v_i]$ and $\Ledger[j'][i][r + v_i]$.
  This holds because of Lemma~\ref{lem:past-perfect} invoked with parties $\Y[j][i]$ and $\Y[j'][i]$,
  rounds $r_1 = r_2 = r + v_i$, $r_3 = r + v_i + 1$ and $r^* < r$.
  During round $r_3$, the new honest transaction is due to any honest
  relayer.\qed
\end{proof}

% TODO: Define the relationship between Z and Z';
%       we are hoping that Z' will have exactly the same writes as Z
%       (perhaps more due to adversarial writes) for each party
%       and that those will appear in "close enough" times (maybe up to $u$ away
%       from the original)
\begin{conjecture}[Rollerblade Simulation]\label{conj:simulation}
  For all \rollerblade-overlay-respecting protocols $\Pi$
  and any sequence of \rollerblade-underlying-respecting
  protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$
  for the \rollerblade-belief-system $\mathcal{B}$ of $\mathcal{Y}$
  and honesty correspondence $\mathcal{H}$,
  the compositor \rollerblade of Section~\ref{sec:construction} is
  $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful},
  where $n = \ell$, $\Delta = \max\{u_i\}_{i \in [n]}$,
  and $u_i$ is the promised liveness of $\Y[][i]$.
\end{conjecture}
\begin{proof}[Sketch]
  Let $\Pi$, $\mathcal{Y}$, $\mathcal{B}$, $\mathcal{H}$,
  and $\Delta$ be as in the statement.
  Let the adversary $\mathcal{A}$, the belief $B \in \mathcal{B}$,
  and the environment $\mathcal{Z}$, the number of compositor parties $m$,
  and the index of the compositor $j$ of interest be arbitrary
  as in the statement, and set $H = \mathcal{H}(B)$.

  We will prove faithfulness by
  construction of the simulator $S$ and environment $\mathcal{Z}'$.

  % TODO: consider removing the environment $\mathcal{Z}'$
  The simulator $S$ and environment $\mathcal{Z}'$ work in tandem
  as follows.
  Initially, $S$ samples an execution
  $\mathcal{E}^*$ in the emulation setting from
  % TODO: is the number of validators in \Y[][1] hard-coded into it?
  $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$.
  Let $R$ be the duration of $\mathcal{E}^*$ in rounds.
  % TODO: Describe how the simulator works
  The simulator looks at compositor party $j$ of $\mathcal{E}^*$
  and its $\Y[j][1], \ldots, \Y[j][n]$.
  The environment $\mathcal{Z}'$ chooses the duration, in rounds, of
  $\mathcal{E}'$ to be $R - \Delta_v - 1$.

  The simulator initially obtains, for every $i \in [n]$,
  a copy of the configuration $M_i$ of the ITI $\RB[j]$ from $\mathcal{E}^*$ at the end of
  $\mathcal{E}^*$.
  The simulator calls $\prepareSimulationInputs(i, \simulationRound, \realityRound)$ on $M_i$
  \emph{in vitro}, where \simulationRound is the last round of execution $\mathcal{E}'$
  and \realityRound is the last round of execution $\mathcal{E}^*$, to obtain the pair
  $(\writeboxes^i, \inboxes^i)$
  (the simulator can make this call to $\prepareSimulationInputs$ without affecting the execution).
  At the beginning of round $r$ of $\mathcal{E}'$, the simulator calls
  $\lwrite(\data)$ on party $i$
  for every $\data \in \writeboxes^i[r - 1]$.
  When $\mathcal{Z}'$ activates party $i$ during round $r$,
  if party $i$ invokes the network receive method $\recv()$, then $\mathcal{Z}'$
  provides $\inboxes^i[r - 1]$.

  We note that $S$ uses the adversary $\mathcal{A}$ and the
  environment $\mathcal{Z}$ in this simulation, so $\mathcal{E}$
  and $\mathcal{E}^*$ are identically distributed.
  For (1) it suffices to show that for all $j$,
  $\LCView_{j,H,\Delta_v}(\mathcal{E}^*) = \PEView_H(\mathcal{E}')$
  (i.e., we will show the these two random variables are equal,
  not just equal by distribution),
  and similarly for (2) it suffices to show that for all $j$,
  $\LCExtern_j(\mathcal{E}^*) \late{\Delta} \PEExtern(\mathcal{E}')$
  (i.e., we will show that the externalities of $\mathcal{E}'$ are $\Delta$-late
  with respect to $\mathcal{E}^*$, not just distributionally $\Delta$-late).

  \noindent
  \textbf{Claim 1: $\LCView(\mathcal{E}^*) = \PEView(\mathcal{E}')$.} We need to show
  that the views of all \emph{honest} parties in the two executions are identical. Let
  $i$ be an arbitrary party in $H$.

  Since $\mathcal{Z}$ is $B$-respecting, therefore $B(\mathcal{E}^*)$ holds.
  {\color{red} Finish the claim proof...}

  \noindent
  \textbf{Claim 2: $\LCExtern(\mathcal{E}^*) \late{\Delta} \PEExtern(\mathcal{E}')$.}

  {\color{red} Finish the claim proof...}
\end{proof}

% TODO: Consider the case of "written communication", or "transferable origin" constructions
% \begin{definition}[Authenticated Communication Protocol]
%       An Authenticated Communication Protocol ACP is...
%       Define what is the syntax of $\Sigma$... (and maybe use a different letter)
%       ... TODO
% \end{definition}
% \begin{definition}[Peer-to-Peer ACP]
%       Make an ACP by composing an existentially unforgeable signature scheme and
%       a synchronous network... TODO
% \end{definition}
% The above definition still allows for use of randomness within the $\Sigma$ protocol of the
% signature, which captures the functionality of generating keys, signing, and verifying
% messages. Typical BFT protocols such as Streamlet~\cite{streamlet} and Hot Stuff~\cite{hotstuff}
% satisfy the \emph{soft determinism} definition.
