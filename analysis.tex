\section{Analysis}

To aid the analysis, we assume that the ITIs contain all the previous transcript
of their execution (a history of machine configurations).

% \begin{definition}[Determinism]
%       Let $\Pi^\Sigma$ be a State Machine Replication protocol that makes
%       oracle use of a signature protocol $\Sigma = (\textsf{Gen}, \textsf{Sig}, \textsf{Ver})$.
%       The protocol $\Pi$ is called \emph{soft deterministic} if,
%       when executed as an interactive turing machine $\Pi^\Sigma(i)$ initialized for party
%       with index $i$, the machine does not make use of any local randomness.
% \end{definition}
%
% TODO: define underlying, overlay, good, VIEW...

\begin{definition}[Lateness]
\end{definition}

\begin{definition}[Exec]
\end{definition}

\begin{definition}[View]
\end{definition}

% TODO: Move this to definitions? Expand this intuitive explanation,
% and give it a title
% Potential generalization: Use a different H_Z and H_Y that indicate
% which Ys are "good" and which Zs are supposed to be "honest", and
% make H_Z a function of H_Y, to be defined by the DPCP.
% This would allow having a different number of Zs and Ys,
% and each of the Zs could depend on different, and potentially multiple, Ys;
% and each Y could help multiple Zs.

A \emph{compositor} is a protocol that
runs an \emph{overlay} distributed protocol $\Pi$ on top of a set of
$n$ \emph{underlying} distributed protocols $\Y[][1], \ldots, \Y[][i], \ldots, \Y[][n]$.
The protocol $\Pi$ is generally designed
to work in the \emph{party setting} with a network (such as an authenticated channels network)
connecting its instances directly.
The compositor executes
$\Pi$ in the \emph{emulated setting} by utilizing the underlying
$\Y[][i]$ protocols to help with the emulation and communication between the
overlay protocol instances.
Multiple instances $\Lambda_1, \ldots, \Lambda_j, \ldots, \Lambda_m$
of the compositor are executed.
Each $j^\text{th}$ compositor instance promises to emulate the execution of multiple
instances of $\Pi$ ($\Z[j][1], \ldots, \Z[j][i], \ldots \Z[j][n]$).
These emulated $\Z$ instances should behave similarly to instances of $\Pi$
running in a stand-alone setting.

\begin{definition}[Compositor]
  A \emph{compositor} $\Lambda$ with overlay $\Pi$ and underlying $\Y[][1], \ldots, \Y[][n]$,
  is a family of interactive machines
  $\Lambda_{\Pi,(\Y[][1], \ldots, \Y[][n])}$ providing the following
  functionalities:

  \begin{enumerate}
    \item \textbf{construct}$(\sid)$.
    \item \textbf{writeToMachine}$(i, \data)$.
    \item \textbf{emulateMachine}$(i, r)$. % <-- Z
  \end{enumerate}
\end{definition}

The compositor is constructed by calling \emph{construct} with parameter the session identifier $\sid$.
Note that compositors are permissionless, as they don't know their instance identity $j \in \mathbb{N}$.
Each compositor instance provides a \emph{writeToMachine}
functionality that allows writing data to the $i^\text{th}$ emulated machine.
It also provides an \emph{emulateMachine} functionality that promises to emulate the execution of
the $i^\text{th}$ instance of $\Pi$ up to round $r$, and return the instance of this emulation
at round $r$ (and note that this contains the full transcript of the emulation).

Even though we will not do the analysis in the full Universal Composability (UC) framework, and
we treat executions as stand-alone, we do adopt some of the notation of the UC framework.
Let $\LCExec(\Lambda, \Pi, ({\Y[][1]}, \cdots, {\Y[][n]}), \mathcal{A}, \mathcal{Z}, \mathcal{H})$
denote the transcript of an execution of the DPCP protocol $\Lambda$ parametrized with overlay protocol $\Pi$,
and underlying protocols $\Y[][1], \ldots, \Y[][n]$, adversary $\mathcal{A}$, environment $\mathcal{Z}$,
indices of honest parties $\mathcal{H}$.
Following the notation of the UC framework, we define the notion of an \emph{execution}
and a \emph{view}... % TODO(tzinas/dionyziz)... define these.
% Define how the environment Z and the environment Z' functions step by step
% e.g., the environment Z is given $m$ compositor parties to spin up
% and both environments must orchestrate the execution in a lockstep manner

% TODO: Define belief system and honesty correspondence
% TODO: Define a belief-respecting environment
We are now ready to define the notion of \emph{faithfulness} of a
compositor, which captures the
correspondence between the party setting execution and the emulated setting
execution of $\Pi$. Roughly, a compositor is called \emph{faithful} is these
two settings are identical in the eyes of the honest parties.
This faithfulness may be conditioned to work only on certain classes
of overlay protocols $\Pi$ and underlying protocols $\Y$, and may
require that a certain subset $\mathcal{H}$ of these $\Y$s are well-behaved.
This good-behavior is captured by the notion of a \emph{goodness} predicate $Q$.

% TODO: Mention that the validator and other protocol settings for \Y[][i]
% are hard-coded into \Y[][i]
\begin{definition}[Compositor Faithfulness]
  A compositor $\Lambda$
  is $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful}
  for an overlay protocol $\Pi$,
  a number of overlay parties $n \in \mathbb{N}$,
  a sequence of underlying protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  a belief system $\mathcal{B}$,
  honesty correspondence $\mathcal{H}: \mathcal{B} \longrightarrow 2^{[n]}$,
  and delay $\Delta \in \mathbb{N}$ if:

  For all beliefs $B \in \mathcal{B}$,
  for all PPT adversaries $\mathcal{A}$ and all
  $B$-respecting PPT environments $\mathcal{Z}$,
  for all number of compositor parties $m \in \mathbb{N}$,
  for all compositor party indices $j \in [m]$,
  % TODO: There is no need for the polynomiality constraint on A and Z,
  % but the reduction maintains polynomiality
  there is a PPT simulator $\mathcal{S}$ and there is a
  PPT environment $\mathcal{Z}'$ such that
  the following holds:

  \begin{enumerate}
    \item $\LCView_j(\mathcal{E}) \distreq \PEView(\mathcal{E}')$
    \item $\LCExtern_j(\mathcal{E}) \latedistr{\Delta} \PEExtern(\mathcal{E}')$
  \end{enumerate}

  where execution $\mathcal{E}$ is sampled from
  % TODO: Do not use "EXEC", as this is inconsistent with the UC framework
  $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$
  % TODO: B should only depend on the collective execution of \Y, not anything else
  and execution $\mathcal{E}'$ is sampled from

  \[
  \PEExec(\Pi, \mathcal{S}, \mathcal{Z}', n, \mathcal{H}(B), \Delta)\,.
  \]
\end{definition}

% Remark: Differences from a UC-style proof

\begin{lemma}[Past Perfect]
  Consider a temporal ledger protocol $\Y$
  constrained to report ledgers in which each transaction appears at most once.
  Consider an execution $\Exec$ with duration $R$ rounds in which $\Y$ is
  safe, live with liveness $u$, timely with timeliness $v$.
  If for some honest party $P_1$ and some round $r_1$ it holds that
  $(r^*, \tx) \in \Ledger[P_1][][r_1]$, then
  for all honest parties $P_2$ and for all rounds $r^* + v < r_2 < R - u - 1$
  it holds that
  $(r^*, \tx) \in \Ledger[P_2][][r_2]$,
  % TODO:
  % We may be able to remove this extra assumption if
  % we change temporal ledgers to also report their "current time"
  % under the following constraints:
  % 1) In synchronous settings, or after GST in psync, the "current time"
  %    reported by the ledger must not be too far in the past (more than $v$?)
  % 2) The "current time" reported must march only forward;
  %    the next "current time" reported must be larger than the
  %    current "current time" reported.
  % 3) If I read the ledger at some round r_1 and the current time reported
  %    is r_1', then I read the ledger again at round r_2 > r_1, then
  %    any *new* transactions that appear must have a recorded round of
  %    at least r_1'.
  % We may be able to replace "timeliness" completely with the above
  % definition.
  as long as at least one new honest transaction $\tx'$ appears at
  any round $r_3 > r_2$.
\end{lemma}
\begin{proof}
  Consider an execution as in the statement and suppose, towards a contradiction,
  that $(r^*, \tx) = \Ledger[P_1][][r_1][k]$ for some $k \in \mathbb{N}$
  with $r^* + v < r_2$, but
  $(r^*, \tx) \not\in \Ledger[P_2][][r_2]$.
  Due to liveness,
  $(*, \tx') = \Ledger[P_1][][r_3 + u][k']$ for some $k' \in \mathbb{N}$.
  As $\tx'$ is new, it is not in $\Ledger[P_1][][r_1]$.
  Because the ledger is safe, $k' > k$.
  Due to liveness, $(*, \tx') \in \Ledger[P_2][][r_3 + u]$.
  Due to safety, $(*, \tx') = \Ledger[P_2][][r_3 + u][k']$.
  Therefore, $|\Ledger[P_2][][r_3 + u]| \geq k$.
  Due to safety, $\Ledger[P_2][][r_3 + u][k] = (r^*, \tx)$.
  Because $\Ledger[P_2][][r_3 + u]$ has a transaction
  that $\Ledger[P_2][][r_2]$ does not have (namely $\tx$)
  and it is safe, therefore
  $(r^*, \tx) \in \Ledger[P_2][][r_3 + u][|\Ledger[P_2][][r_2]|{:}]$.
  Since $r^* < r_2 - v$, this contradicts the timeliness with parameter $v$.\qed
\end{proof}

The above property, which follows from safety, liveness, timeliness and
contiguous honest participation is also known in the literature as
\emph{persistence}~\cite{backbone}.

\begin{definition}[Rollerblade Belief System and Honesty Correspondence]
  Given a sequence of \rollerblade-underlying-respecting
  protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$,
  define for each $i \in [\ell]$ the following predicate on
  a collective execution $\mathcal{E}$ of $\mathcal{Y}$:

  \[
    \text{good}_i(\mathcal{E}) = \text{``} \Y[][i] \text{ is safe, live$(u_i)$, and timely$(v_i)$ in $\mathcal{E}$''}
  \]

  Define $\mathcal{H}^{-1}$ on the domain $2^{[n]}$ as
  $\mathcal{H}^{-1}(H) = \bigwedge_{i \subseteq H} \text{good}_i$.
  Then the \emph{\rollerblade honesty correspondence $\mathcal{H}$ of $\mathcal{Y}$}
  is the inverse of $\mathcal{H}^{-1}$ and the \emph{\rollerblade belief system
  $\mathcal{B}$ of $\mathcal{Y}$} is the domain of $\mathcal{H}$.
\end{definition}

% TODO: Define the relationship between Z and Z';
%       we are hoping that Z' will have exactly the same writes as Z
%       (perhaps more due to adversarial writes) for each party
%       and that those will appear in "close enough" times (maybe up to $u$ away
%       from the original)
\begin{conjecture}[Rollerblade Simulation]\label{conj:simulation}
  For all \rollerblade-overlay-respecting protocols $\Pi$
  and any sequence of \rollerblade-underlying-respecting
  protocols $\mathcal{Y} = (\Y[][1], \ldots, \Y[][\ell])$
  for the \rollerblade-belief-system $\mathcal{B}$ of $\mathcal{Y}$
  and honesty correspondence $\mathcal{H}$,
  the compositor \rollerblade of Section~\ref{sec:construction} is
  $(\Pi, n, \mathcal{Y}, \mathcal{B}, \mathcal{H}, \Delta)$-\emph{faithful},
  where $n = \ell$, $\Delta = \max\{u_i\}_{i \in [n]}$,
  and $u_i$ is the promised liveness of $\Y[][i]$.
\end{conjecture}
\begin{proof}[Sketch]
  Let $\Pi$, $\mathcal{Y}$, $\mathcal{B}$, $\mathcal{H}$,
  and $\Delta$ be as in the statement.
  Let the adversary $\mathcal{A}$, the belief $B \in \mathcal{B}$,
  and the environment $\mathcal{Z}$, the number of compositor parties $m$,
  and the index of the compositor $j$ of interest be arbitrary
  as in the statement.

  We will prove faithfulness by
  construction of the simulator $S$ and environment $\mathcal{Z}'$.

  The simulator $S$ and environment $\mathcal{Z}'$ work as follows.
  Initially, $S$ samples an execution
  $\mathcal{E}^*$ in the emulation setting from
  % TODO: is the number of validators in \Y[][1] hard-coded into it?
  $\LCExec_m(\Lambda, \mathcal{Y}, \mathcal{A}, \mathcal{Z})$.
  % TODO: Describe how the simulator works
  The simulator looks at compositor party $j$ of $\mathcal{E}^*$
  and its $\Y[j][1], \ldots, \Y[j][n]$.
  The environment $\mathcal{Z}'$ chooses the number of rounds in
  $\mathcal{E}'$ to be the same as the number of rounds in $\mathcal{E}^*$.
  For every round $r$ of the execution $\mathcal{E}^*$,
  and for every $i \in [n]$, the simulator obtains $\Y[j][i][r]$
  (the simulator can do this by obtaining a copy of the ITI
  configuration for the $i^\text{th}$ distributed ledger client $\Y[j][i]$
  of party $j$ at the end of round $r$ and executing $\lread$ on
  it \emph{in vitro}).

  {\color{red} Describe how the simulator works...}

  We note that $S$ uses the adversary $\mathcal{A}$ and the
  environment $\mathcal{Z}$ in this simulation, so $\mathcal{E}$
  and $\mathcal{E}^*$ are identically distributed.
  For (1) it suffices to show that for all $j$,
  $\LCView_j(\mathcal{E}^*) = \PEView(\mathcal{E}')$
  (i.e., we will show the these two random variables are equal,
  not just equal by distribution),
  and similarly for (2) it suffices to show that for all $j$,
  $\LCExtern_j(\mathcal{E}^*) \late{\Delta} \PEExtern(\mathcal{E}')$
  (i.e., we will show that the externalities of $\mathcal{E}'$ are $\Delta$-late
  with respect to $\mathcal{E}^*$, not just distributionally $\Delta$-late).

  \noindent
  \textbf{Claim 1: $\LCView(\mathcal{E}^*) = \PEView(\mathcal{E}')$.} We need to show
  that the views of all \emph{honest} parties in the two executions are identical. Let
  $i$ be an arbitrary party in $H$.

  Since $\mathcal{Z}$ is $B$-respecting, therefore $B(\mathcal{E}^*)$ holds.
  {\color{red} Finish the claim proof...}

  \noindent
  \textbf{Claim 2: $\LCExtern(\mathcal{E}^*) \late{\Delta} \PEExtern(\mathcal{E}')$.}

  {\color{red} Finish the claim proof...}
\end{proof}

\begin{conjecture}[Cross-party]\label{conj:cross-party}
  Consider a \rollerblade execution $\mathcal{E}$ with $n \in \mathbb{N}$ underlying
  and $m \in \mathbb{N}$ overlay parties.
  For all rounds $r$, all overlay parties $\RB[j], \RB[j']$,
  and all underlying $i \in \mathbb{N}$:

  \[
    \Sim[j][r](i, r - v_i, r) = \Sim[j][r](i, r - v_i, r)
  \]
\end{conjecture}

% TODO: Consider the case of "written communication", or "transferable origin" constructions
% \begin{definition}[Authenticated Communication Protocol]
%       An Authenticated Communication Protocol ACP is...
%       Define what is the syntax of $\Sigma$... (and maybe use a different letter)
%       ... TODO
% \end{definition}
% \begin{definition}[Peer-to-Peer ACP]
%       Make an ACP by composing an existentially unforgeable signature scheme and
%       a synchronous network... TODO
% \end{definition}
% The above definition still allows for use of randomness within the $\Sigma$ protocol of the
% signature, which captures the functionality of generating keys, signing, and verifying
% messages. Typical BFT protocols such as Streamlet~\cite{streamlet} and Hot Stuff~\cite{hotstuff}
% satisfy the \emph{soft determinism} definition.