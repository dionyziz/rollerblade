\begin{algorithm}[H]
  \caption{\label{alg.view}
    The \emph{view} function ran by a Rollerblade party
    capturing the perceived view of running overlay party
    $j$
    based on the underlying DLP ledger $L_j$. The transcript
    returned is a sequence of \emph{send} messages according
    to the overlay protocol's desired format.
  }
  \begin{algorithmic}[1]
    \Function{\sf prepare-simulation-inputs}{$i, \Ledger[][i], r$}
      \Let{\sf consumed-lengths}{[\,]}
      \Let{\inboxes}{[\,]}
      \Let{\writes}{[\,]}

      \For{$P \in \overline{P}$}
        \Let{\textsf{outbox.append}}{[\,]}
      \EndFor

      \Let{L}{\textsf{decode-underlying}(\Y[][i]\textsf{.decode}, \Ledger[][i])}
      \For{$(r, m) \in L$}
        \If{$m\textsf{.type} = \text{`checkpoint'}$}
          \Let{i'}{m\textsf{.from}}
          \Let{\Ledger[][i']}{\Y[][i']\textsf{.untranscribe}(m\textsf{.data.certificate})}
          \CommentLine{TODO: We need to translate overlay rounds to underlay liveness here}
          % TODO(dionyziz): Rename to outboxes?
          \Let{\outbox}{\textsf{simulate}(i', \Ledger[][i'], r - 1)\textsf{.outbox}}
          \Let{\inbox}{\textsf{inbox-to-outbox}(\textsf{outbox}[i'], \textsf{newOutbox}, i', r)}
          % TODO: Keep only new messages?
          \Let{\textsf{consumed-lengths}[i']}{|\outbox|}
        \EndIf
        \If{$m\textsf{.type} = `\text{write}'$}
          \State{$\writes\textsf{.append}(m\textsf{.data})$}
        \EndIf
        \Let{\sf inbox}{\textsf{inbox} \concat \textsf{newEvents}}
      \EndFor
      \State\Return{$(\writes, \inboxes)$}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
