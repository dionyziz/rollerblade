% TODO: write these in the form of a compositor protocol (a class with multiple methods)
\begin{algorithm}
  \caption{\label{alg.simulate}
    The \emph{simulate} function ran by a \rollerblade party
    executing the overlay protocol for party $i$ at a
    particular \emph{simulation round} using ledger $\Ledger[j][i]$.
    The simulation returns the outbox (messages
    ``sent'' to other parties) and the instance $\Z[j][i]$ of the simulated machine
    as reported by overlay party $i$.
  }
  %TODO: Rename simulate function
  \begin{algorithmic}[1]
    \Function{\simulate}{$i, \Ledger[j][i], \simulationRound$}
      \Let{\textsf{in}}{\this.\prepareSimulationInputs(i, \Ledger[j][i], \simulationRound)}\label{alg.simulate:recursion}
      \Let{(\writeboxes, \inboxes)}{\textsf{in}}

      \Let{\outboxes}{[[\,]]}\label{alg.simulate:outboxes-init}
      \Let{\inboxThisRound}{[\,]}
      \Let{\outboxThisRound}{[\,]}

      \Function{\send}{recp, \msg}\label{alg.simulate:send}
        \State{$\outboxThisRound.\append(\{\textsf{to}{:} \textsf{recp}, \msg{:}\msg\})$}
      \EndFunction

      \Function{\recv}{\,}\label{alg.simulate:receive}
        \State\Return{\inboxThisRound}
      \EndFunction

      \CommentLine{Oracles passed to the overlay protocol}
      \Let{\net}{(\textsf{send}, \textsf{receive})}

      \Let{\Z[j][i]}{\new \Pi^\net(\this.\Delta, j, n)}\label{alg.simulate:construct}
      \For{$r \gets 1 \text{ to } \simulationRound$}\label{alg.simulate:for}
        \Let{\sf roundReceives}{[\,]}
        \Let{\outboxThisRound}{[\,]}\label{alg.simulate:outboxThisRound-init}

        \For{$\textsf{data} \in \textsf{writeboxes}[r - 1]$}\label{alg.simulate:write}
          \CommentLine{Submit writes recorded at $r - 1$}
          \State{$\Z[j][i].\textsf{write}(\textsf{data})$}
        \EndFor

        \CommentLine{Prepare network msgs to be delivered at $r$}
        \Let{\inboxThisRound}{\inboxes[r - 1]}\label{alg.simulate:netin}

        \CommentLine{Run a single round $r$ of overlay machine}
        \State{$\Z[j][i].\textsf{execute}()$}\label{alg.simulate:execute}

        \State{$\outboxes.\append(\outboxThisRound)$}\label{alg.simulate:outboxes-append}
      \EndFor

      \State\Return{$\{\outboxes{:} \outboxes, Z{:} \Z[j][i]\}$}\label{alg.simulate:return}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
