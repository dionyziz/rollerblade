\begin{algorithm}
  \caption{\label{alg.simulate}
    The \emph{simulate} function ran by a \rollerblade party
    executing the overlay protocol for party $i$ at a
    particular \emph{simulation round} using ledger $\Ledger[j][i]$.
    The simulation returns the outbox (messages
    ``sent'' to other parties) and the instance $\Z[j][i]$ of the simulated machine
    as reported by overlay party $i$.
  }
  \begin{algorithmic}[1]
    \Function{\sf simulate}{$\sid, \Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound$}
      \Let{(\writeboxes, \inboxes)}{\prepareSimulationInputs(\sid, \Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound)}\label{alg.simulate:recursion}

      \Let{\sf outboxes}{[[\,]]}\label{alg.simulate:outboxes-init}
      \Let{\inboxThisRound}{[\,]}
      \Let{\outboxThisRound}{[\,]}

      \Function{\sf send}{recp, m}\label{alg.simulate:send}
        \State{$\outboxThisRound.\append(\{\textsf{to}{:} \textsf{recp}, \textsf{msg}{:}m\})$}
      \EndFunction

      \Function{\sf receive}{\,}\label{alg.simulate:receive}
        \State\Return{\inboxThisRound}
      \EndFunction

      \CommentLine{Oracles passed to the overlay protocol}
      \Let{\net}{(\textsf{send}, \textsf{receive})}

      \Let{\Z[j][i]}{\new \Pi^\net(j, n)}\label{alg.simulate:construct}
      \State{$\Z[j][i].\textsf{execute}()$}\Comment{Execute the machine for round $0$ without any inputs}
      \For{$r \gets 1 \text{ to } \simulationRound$}\label{alg.simulate:for}
        \Let{\sf roundReceives}{[\,]}
        \Let{\outboxThisRound}{[\,]}\label{alg.simulate:outboxThisRound-init}

        \For{$\textsf{data} \in \textsf{writeboxes}[r - 1]$}\label{alg.simulate:write}
          \CommentLine{Submit `write' commands recorded at round $r - 1$}
          \State{$\Z[j][i].\textsf{write}(\textsf{data})$}
        \EndFor

        \CommentLine{Prepare network messages to be delivered at round $r$}
        \Let{\inboxThisRound}{\inboxes[r - 1]}\label{alg.simulate:netin}

        \CommentLine{Run a single round of the overlay machine for round $r$}
        \State{$\Z[j][i].\textsf{execute}()$}\label{alg.simulate:execute}

        \State{$\outboxes.\append(\outboxThisRound)$}\label{alg.simulate:outboxes-append}
      \EndFor

      \State\Return{$\{\outboxes{:} \outboxes, Z{:} \Z[j][i]\}$}\label{alg.simulate:return}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
