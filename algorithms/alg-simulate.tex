\begin{algorithm}[H]
  \caption{\label{alg.simulate}
    The \emph{simulate} function ran by a \rollerblade party
    executing the overlay protocol for party $i$ at a
    particular \emph{simulation round} using ledger $\Ledger[j][i]$.
    The simulation returns the outbox (messages
    ``sent'' to other parties) and the instance $\Z[j][i]$ of the simulated machine
    as reported by overlay party $i$.
  }
  \begin{algorithmic}[1]
    \Function{\sf simulate}{$\sid, \Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound$}
      \Let{(\writes, \inboxes)}{\prepareSimulationInputs(\sid, \Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound)}

      \Let{\sf outboxes}{[\,]}
      \Let{\sf inboxThisRound}{[\,]}
      \Let{\sf outboxThisRound}{[\,]}

      \Function{\sf send}{recp, m}
        \State{$\textsf{outboxThisRound}\textsf{.append}((\textsf{recp}, m))$}
      \EndFunction

      \Function{\sf receive}{}
        \State\Return{\sf inboxThisRound}
      \EndFunction

      \CommentLine{Oracles passed to the overlay protocol}
      \Let{\net}{(\textsf{send}, \textsf{receive})}

      \Let{\Z[j][i]}{\new \Pi^\net(j, n)}
      \State{$\Z[j][i].\textsf{execute}()$}\Comment{Execute the machine for round $0$ without any inputs}
      \For{$r \in [\simulationRound]$}
        \Let{\sf roundReceives}{[\,]}
        \Let{\sf outboxThisRound}{[\,]}

        \For{$\textsf{data} \in \textsf{writes}[r]$}
          \State{$\Z[j][i].\textsf{write}(\textsf{data})$}
        \EndFor

        \For{$(\textsf{from}, m) \in \textsf{inboxes[r]}$}
          \State{$\textsf{inboxThisRound.append}((\textsf{from},m))$}
        \EndFor

        \CommentLine{Run a single round of the overlay machine for round $r+1$}
        \State{$\Z[j][i].\textsf{execute}()$}

        \State{$\textsf{outboxes.append}(\textsf{outboxThisRound})$}
      \EndFor

      \State\Return{$\{\textsf{outboxes}{:} \textsf{outboxes}, Z{:} \Z[j][i]\}$}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
