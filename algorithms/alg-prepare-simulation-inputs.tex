\begin{algorithm}
  \caption{\label{alg.prepare-simulation-inputs}
    The \emph{prepare simulation inputs} function ran by \rollerblade party $j$
    to prepare the necessary inputs for the simulation of overlay party
    $i$ at round $\simulationRound$ based on the underlying ledger $\Ledger[j][i]$.
    The inputs consist of \emph{writes} (user inputs)
    and \emph{inboxes} (network inputs produced as network output when recursively
    simulating all other parties $\Y[j][i']$)
    arranged by round.
  }
  \begin{algorithmic}[1]
    \Function{\prepareSimulationInputs}{$\sid, \Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound$}
      \If{$\simulationRound \geq \realityRound - v_i$}
        \State\Return{$\bot$} \Comment{Simulation round is too far in the future}
      \EndIf

      \Let{\inboxes}{[[\,]]}
      \Let{\writeboxes}{[[\,]]}

      \For{$r \gets 1 \text{ to } \simulationRound$}\label{alg.prepare-simulation-inputs:init}
        \CommentLine{For each round $r$: $\inboxes[r]$ and $\writeboxes[r]$ is a \emph{list} of inputs}
        \State{\inboxes.\append([\,])}
        \State{\writeboxes.\append([\,])}
      \EndFor

      \Let{n}{|\Y[j]|}\Comment{Number of overlay parties}

      % TODO(dionyziz): Typeset \CommentLine and \Comment to both use the same \emph{} style
      \CommentLine{How many messages each other overlay party $i'$ has ``sent'' us}
      \Let{\sf \consumedLengths}{[\,]}

      \For{$i' \gets 1 \text{ to } n$}
        \State{\consumedLengths.\append(0)}
      \EndFor

      \Let{L}{\decodeUnderlying(\sid, \Y[j][i]\textsf{.decode}, \Ledger[j][i])}\label{alg.prepare-simulation-inputs:decode-underlying}
      \For{$(r, \instruction) \in L$}\label{alg.prepare-simulation-inputs:for}
        % TODO: Mention that timeliness (time marches forward)
        \If{$r \geq \simulationRound$}\label{alg.prepare-simulation-inputs:early-exit}
          \CommentLine{Further data is irrelevant for the simulation at round $\simulationRound$}
          \Break
        \EndIf
        % TODO(dionyziz): Turn this into "switch"?
        \If{$\instruction\textsf{.type} = \text{`write'}$}
          \State{$\writeboxes[r].\append(\instruction\textsf{.data})$}\label{alg.prepare-simulation-inputs:write}
          \Continue
        \EndIf
        \If{$\instruction\textsf{.type} = \text{`checkpoint'}$}
          \Let{i'}{\instruction\textsf{.from}}
          \Let{\ImaginaryLedger[j][i']}{\Y[j][i']\textsf{.untranscribe}(\instruction\textsf{.data.certificate})}\label{alg.prepare-simulation-inputs:untranscribe}
          \Let{\outboxes}{\textsf{simulate}(\Pi, i', \ImaginaryLedger[j][i'], \Y[j], r - u_i - v_{i'} - 1, r - u_i)\textsf{.outboxes}}\label{alg.prepare-simulation-inputs:recursion}
          \Let{\textsf{netins}}{\outboxesToInbox(\outboxes, i', i)}\label{alg.prepare-simulation-inputs:outboxes-to-inbox}
          \Let{\unprocessedNetins}{\textsf{netins}[\consumedLengths[i']{:}]}

          \For{$\netin \in \unprocessedNetins$}\label{alg.prepare-simulation-inputs:for-netin}
            \State{$\inboxes[r].\append(\netin)$}
          \EndFor
          \Let{\consumedLengths[i']}{\consumedLengths[i'] + |\unprocessedNetins|}\label{alg.prepare-simulation-inputs:consumed-lengths}
        \EndIf
      \EndFor
      \State\Return{$(\writeboxes, \inboxes)$}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
