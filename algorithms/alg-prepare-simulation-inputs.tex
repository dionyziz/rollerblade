\begin{algorithm}[H]
  \caption{\label{alg.prepare-simulation-inputs}
    The \emph{prepare-simulation-inputs} function ran by \rollerblade party $j$
    to prepare the necessary inputs for the simulation of overlay party
    $i$ at round $\simulationRound$ based on the underlying ledger $\Ledger[j][i]$.
    The inputs consist of \emph{writes} (user inputs)
    and \emph{inboxes} (network inputs produced as network output when recursively
    simulating all other parties $\Y[j][i']$)
    arranged by round.
  }
  \begin{algorithmic}[1]
    \Function{\prepareSimulationInputs}{$\Pi, i, \Ledger[j][i], \Y[j], \simulationRound, \realityRound$}
      \Let{v}{\max_{\Y[j][i'] \in \Y[j]}{\{\Y[j][i'].v\}}}
      \If{$\simulationRound \geq \realityRound - v$}
        \State\Return{$\bot$} \Comment{Simulation round is too far in the future}
      \EndIf

      \Let{\inboxes}{[\,]}
      \Let{\writes}{[\,]}

      \For{$r \in [\simulationRound]$}
        \CommentLine{For each round $r$, $\inboxes[r]$ and $\writes[r]$ is a \emph{list} of inputs}
        \State{\inboxes\textsf{.append}([\,])}
        \State{\writes\textsf{.append}([\,])}
      \EndFor

      \Let{n}{|\Y[j]|}\Comment{Number of overlay parties}

      \Let{\sf \consumedLengths}{[\,]}

      \For{$i' \in [n]$}\Comment{How many messages each other overlay party $i'$ has ``sent'' us}
        \State{\consumedLengths.\textsf{append}(0)}
      \EndFor

      \Let{L}{\textsf{decode-underlying}(\Y[j][i]\textsf{.decode}, \Ledger[][i])}
      \For{$(r, \instruction) \in L$}
        % TODO: Mention that timeliness (time marches forward)
        \If{$r \geq \simulationRound$}
          \CommentLine{Further data is irrelevant for the simulation at round $\simulationRound$}
          \Break
        \EndIf
        % TODO(dionyziz): Turn this into "switch"?
        \If{$\instruction\textsf{.type} = \text{`write'}$}
          \State{$\writes[r]\textsf{.append}(\instruction\textsf{.data})$}
          \Continue
        \EndIf
        \If{$\instruction\textsf{.type} = \text{`checkpoint'}$}
          \Let{i'}{\instruction\textsf{.from}}
          \Let{\Ledger[j][i']}{\Y[][i']\textsf{.untranscribe}(\instruction\textsf{.data.certificate})}
          \Let{\outboxes}{\textsf{simulate}(\Pi, i', \Ledger[j][i'], \Y[j], r - u_i - v_{i'} - 1, r - u_i)\textsf{.outboxes}}
          \Let{\textsf{netins}}{\outboxesToInbox(\outboxes)}
          \Let{\unprocessedNetins}{\textsf{netins}[\consumedLengths[i']{:}]}

          \For{$\netin \in \unprocessedNetins$}
            \State{$\inboxes[r]\textsf{.append}(\netin)$}
          \EndFor
          \Let{\consumedLengths[i']}{\consumedLengths[i'] + |\unprocessedNetins|}
        \EndIf
      \EndFor
      \State\Return{$(\writes, \inboxes)$}
    \EndFunction
    \vskip2pt
  \end{algorithmic}
\end{algorithm}
