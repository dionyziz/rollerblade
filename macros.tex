\newcommand{\tx}{\textsf{tx}}
\newcommand{\LState}{\mathsf{L}}
\newcommand{\negl}{\textsf{negl}(\kappa)}
\newcommand{\view}{\textsc{view}}
\newcommand{\fullview}{\textsc{view}^{t,n}_{\Pi,\mathcal{A},\mathcal{Z}}}
\newcommand{\validityattack}{\textsc{persistence}\textsc{-}\textsc{game}}
\newcommand{\livenessattack}{\textsc{liveness}\textsc{-}\textsc{game}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\approxn}{\widetilde{n}}
\DeclareMathOperator{\diff}{\textsf{diff}\,}
\newcommand{\dexpand}[1]{#1_{\pm\Delta}}

\newcommand{\concat}{\,\|\,}
\newcommand{\conc}{\,\|\,}

\hyphenation{log-a-rith-mic}
\hyphenation{unique-ly}
\hyphenation{ex-tractabil-i-ty}

\algnewcommand\algorithmicon{\textbf{upon}}
\algblockdefx[ON]{On}{EndOn}[1]
{\algorithmicon\ #1\ \algorithmicdo}
{\algorithmicend\ \algorithmicon}

\algnewcommand\waitcommand{\textbf{wait until }}
\def\Wait#1{\State\waitcommand #1}

\def\chain{\mathcal{C}}
\DeclareMathOperator{\Ex}{\mathbb{E}}

\newcommand{\getsrandomly}{\overset{\$}{\gets}}

\newcommand{\Break}{\State\textsf{break}}
\newcommand{\Continue}{\State\textsf{continue}}

\algblockdefx[Protocol]{Protocol}{EndProtocol}
[1]{\textbf{protocol #1}}
[0]{\textbf{end protocol}}

\algblockdefx[Party]{Party}{EndParty}
[1]{\textbf{party #1}}
[0]{\textbf{end party}}

% TODO(dionyziz): Typeset this
\algblock{Try}{EndTry}
\algcblock[Try]{Try}{Catch}{EndTry}
\algcblock{Try}{Catch}{EndTry}

\newcommandx{\RB}[1][1=]{\prescript{#1}{}{\textsf{RB}}}
% \newcommand{\wheel}[3]{\prescript{}{#1}Y^{#2}{#3}}
% TODO: if #1 is not specified, then do not do \prescript
% to avoid unnecessary spacing
\newcommandx{\Y}[3][1=,2=,3=]{\prescript{#1}{}{\textsf{Y}}^{#2}_{#3}}
\newcommandx{\Z}[3][1=,2=,3=]{\prescript{#1}{}{\textsf{Z}}^{#2}_{#3}}
\newcommandx{\Sim}[2][1=,2=]{\prescript{#1}{}{\textsc{Sim}}_{#2}}
\newcommandx{\Ledger}[3][1=,2=,3=]{\prescript{#1}{}{\pmb{L}}^{#2}_{#3}}

\newcommand{\rollerblade}{\textsc{Rollerblade}\xspace}
\newcommand{\fko}{\mathcal{F}_{ko}}
\newcommand{\fto}{\mathcal{F}_{to}}
\newcommand{\ftor}{\mathcal{F}_{tor}}
\newcommand{\inbox}{\textsf{inbox}}
\newcommand{\inboxes}{\textsf{inboxes}}
\newcommand{\writes}{\textsf{writes}}
\newcommand{\outbox}{\textsf{outbox}}
\newcommand{\outboxes}{\textsf{outboxes}}
\newcommand{\sent}{\textsf{sent}}
\newcommand{\recv}{\textsf{recv}}
\newcommand{\this}{\textsf{this}}
\newcommand{\sid}{\textsf{sid}}
\newcommand{\construct}{\textsf{construct}}
\newcommand{\new}{\textsf{new}}
\newcommand{\transcribe}{\textsf{transcribe}}
\newcommand{\untranscribe}{\textsf{untranscribe}}
\newcommand{\serialize}{\textsf{serialize}}
\newcommand{\deserialize}{\textsf{deserialize}}
\newcommand{\encode}{\textsf{encode}}
\newcommand{\decode}{\textsf{decode}}
\newcommand{\execute}{\textsf{execute}}
\newcommand{\simulate}{\textsf{simulate}}
\newcommand{\data}{\textsf{data}}
\newcommand{\instruction}{\textsf{instruction}}
\newcommand{\consumedLengths}{\textsf{consumedLengths}}
\newcommand{\decodeUnderlying}{\textsf{decodeUnderlying}}
\newcommand{\netout}{\textsf{netout}}
\newcommand{\type}{\textsf{type}}
\newcommand{\netin}{\textsf{netin}}
\newcommand{\unprocessedNetins}{\textsf{unprocessedNetins}}
\newcommand{\outboxesToInbox}{\textsf{outboxesToInbox}}
\newcommand{\prepareSimulationInputs}{\textsf{prepareSimulationInputs}}
\newcommand{\net}{\textsc{Net}}
\newcommand{\majorityVote}{\textsf{majorityVote}}
\newcommand{\readFromMachine}{\textsf{readFromMachine}}
\newcommand{\writeToMachine}{\textsf{writeToMachine}}
\newcommand{\append}{\textsf{append}}

\newcommand{\lwrite}{\textsf{write}}
\newcommand{\lread}{\textsf{read}}
\newcommand{\Exec}{\mathcal{E}}
\newcommand{\simulationRound}{\textsf{simulationRound}}
\newcommand{\realityRound}{\textsf{realityRound}}
\newcommand{\msg}{\textsf{msg}}

\newcommandx{\RBView}[6][1=,2=,3=,4=,5=,6=]{\textsc{View}^{\textsf{RB}}(#1,#2,#3,#4,#5,#6)}
\newcommandx{\PEView}[5][1=,2=,3=,4=,5=]{\textsc{View}^{\textsf{PE}}(#1,#2,#3,#4,#5)}
