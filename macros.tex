\newcommand{\tx}{\textsf{tx}}
\newcommand{\LState}{\mathsf{L}}
\newcommand{\negl}{\textsf{negl}(\kappa)}
\newcommand{\view}{\textsc{view}}
\newcommand{\fullview}{\textsc{view}^{t,n}_{\Pi,\mathcal{A},\mathcal{Z}}}
\newcommand{\validityattack}{\textsc{persistence}\textsc{-}\textsc{game}}
\newcommand{\livenessattack}{\textsc{liveness}\textsc{-}\textsc{game}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\approxn}{\widetilde{n}}
\DeclareMathOperator{\diff}{\textsf{diff}\,}
\newcommand{\dexpand}[1]{#1_{\pm\Delta}}

\newcommand{\concat}{\,\|\,}
\newcommand{\conc}{\,\|\,}

\hyphenation{log-a-rith-mic}
\hyphenation{unique-ly}
\hyphenation{ex-tractabil-i-ty}

\algnewcommand\algorithmicon{\textbf{upon}}
\algblockdefx[ON]{On}{EndOn}[1]
{\algorithmicon\ #1\ \algorithmicdo}
{\algorithmicend\ \algorithmicon}

\algnewcommand\waitcommand{\textbf{wait until }}
\def\Wait#1{\State\waitcommand #1}

\def\chain{\mathcal{C}}
\DeclareMathOperator{\Ex}{\mathbb{E}}

\newcommand{\getsrandomly}{\overset{\$}{\gets}}

\newcommand{\Break}{\State\textsf{break}}
\newcommand{\Continue}{\State\textsf{continue}}

\algblockdefx[Protocol]{Protocol}{EndProtocol}
[1]{\textbf{protocol #1}}
[0]{\textbf{end protocol}}

\algblockdefx[Party]{Party}{EndParty}
[1]{\textbf{party #1}}
[0]{\textbf{end party}}

% TODO(dionyziz): Typeset this
% \algblock[Try]{Try}{EndTry}
% \algblockdefx[Try]{Try}{EndTry}
% [0]{\textbf{try}}
% [0]{\textbf{end try}}
%
% \algblockdefx[Catch]{Catch}{EndCatch}
% [0]{\textbf{catch}}{}

\algblock[TryCatch]{Try}{EndTry}
\algcblockdefx[TryCatch]{TryCatch}{Catch}{EndTry}
  [0]{\textbf{catch}}
  [0]{\textbf{end try}}
\algcblockdefx[TryCatch]{TryCatch}{Catch}{EndTry}
  [0]{\textbf{catch}}
  [0]{\textbf{end try}}
\algrenewtext{Try}{\textbf{try}}

% \algcblock[Try]{Try}{Catch}{EndTry}
% \algcblock{Try}{Catch}{EndTry}

\newcommandx{\RB}[1][1=]{\prescript{#1}{}{\textsf{RB}}}
% \newcommand{\wheel}[3]{\prescript{}{#1}Y^{#2}{#3}}
% TODO: if #1 is not specified, then do not do \prescript
% to avoid unnecessary spacing
\newcommandx{\Y}[3][1=,2=,3=]{\prescript{#1}{}{\textsf{Y}}^{#2}_{#3}}
\newcommandx{\Z}[3][1=,2=,3=]{\prescript{#1}{}{\textsf{Z}}^{#2}_{#3}}
\newcommandx{\Sim}[2][1=,2=]{\prescript{#1}{}{\textsc{Sim}}_{#2}}
\newcommandx{\Ledger}[3][1=,2=,3=]{\prescript{#1}{}{\pmb{L}}^{#2}_{#3}}
\newcommandx{\ImaginaryLedger}[3][1=,2=,3=]{\prescript{#1}{}{\mathfrak{L}}^{#2}_{#3}}

\newcommand{\rollerblade}{\textsc{Rollerblade}\xspace}
\newcommand{\fko}{\mathcal{F}_{ko}\xspace}
\newcommand{\fto}{\mathcal{F}_{to}\xspace}
\newcommand{\ftor}{\mathcal{F}_{tor}\xspace}
\newcommand{\inbox}{\textsf{inbox}\xspace}
\newcommand{\inboxes}{\textsf{inboxes}\xspace}
\newcommand{\writeboxes}{\textsf{writeboxes}\xspace}
\newcommand{\writebox}{\textsf{writebox}\xspace}
\newcommand{\outbox}{\textsf{outbox}\xspace}
\newcommand{\outboxes}{\textsf{outboxes}\xspace}
\newcommand{\outboxThisRound}{\textsf{outboxThisRound}\xspace}
\newcommand{\inboxThisRound}{\textsf{inboxThisRound}\xspace}
\newcommand{\sent}{\textsf{sent}\xspace}
\newcommand{\recv}{\textsf{recv}\xspace}
\newcommand{\this}{\textsf{this}\xspace}
\newcommand{\sid}{\textsf{sid}\xspace}
\newcommand{\construct}{\textsf{construct}\xspace}
\newcommand{\new}{\textsf{new}\xspace}
\newcommand{\transcribe}{\textsf{transcribe}\xspace}
\newcommand{\untranscribe}{\textsf{untranscribe}\xspace}
\newcommand{\serialize}{\textsf{serialize}\xspace}
\newcommand{\deserialize}{\textsf{deserialize}\xspace}
\newcommand{\encode}{\textsf{encode}\xspace}
\newcommand{\decode}{\textsf{decode}\xspace}
\newcommand{\execute}{\textsf{execute}\xspace}
\newcommand{\simulate}{\textsf{simulate}\xspace}
\newcommand{\data}{\textsf{data}\xspace}
\newcommand{\instruction}{\textsf{instruction}\xspace}
\newcommand{\certificate}{\textsf{certificate}\xspace}
\newcommand{\consumedLengths}{\textsf{consumedLen}\xspace}
\newcommand{\decodeUnderlying}{\textsf{decodeUnderlying}\xspace}
\newcommand{\netout}{\textsf{netout}\xspace}
\newcommand{\netouts}{\textsf{netouts}\xspace}
\newcommand{\type}{\textsf{type}\xspace}
\newcommand{\netin}{\textsf{netin}\xspace}
\newcommand{\netins}{\textsf{netins}\xspace}
\newcommand{\unprocessedNetins}{\textsf{newNetins}\xspace}
\newcommand{\outboxesToInbox}{\textsf{outboxesToInbox}\xspace}
\newcommand{\prepareSimulationInputs}{\textsf{prepSimInputs}\xspace}
\newcommand{\net}{\textsc{Net}\xspace}
\newcommand{\majorityVote}{\textsf{majVote}\xspace}
\newcommand{\readFromMachine}{\textsf{readFromMachine}\xspace}
\newcommand{\writeToMachine}{\textsf{writeToMachine}\xspace}
\newcommand{\append}{\textsf{append}}

\newcommand{\lwrite}{\textsf{write}\xspace}
\newcommand{\lread}{\textsf{read}\xspace}
\newcommand{\Exec}{\mathcal{E}\xspace}
\newcommand{\simulationRound}{\textsf{simRound}\xspace}
\newcommand{\realityRound}{\textsf{realRound}\xspace}
\newcommand{\msg}{\textsf{msg}\xspace}
\newcommandx{\latedistr}[1]{{\buildrel d \over \lessapprox}_{#1}}
\newcommandx{\late}[1]{\mathbin{\lessapprox_{#1}}}

\newcommand{\distreq}{\buildrel d \over =}

\newcommand{\LCView}{\textsc{View}^{\textsf{LC}}}
\newcommand{\PEView}{\textsc{View}^{\textsf{PE}}}

\newcommand{\LCExtern}{\textsc{Extern}^{\textsf{LC}}}
\newcommand{\PEExtern}{\textsc{Extern}^{\textsf{PE}}}

\newcommandx{\LCExec}[7][1=,2=,3=,4=,5=,6=,7=]{\textsc{Exec}^{\textsf{LC}}(#1,#2,#3,#4,#5,#6,#7)}
\newcommandx{\PEExec}[5][1=,2=,3=,4=,5=]{\textsc{Exec}^{\textsf{PE}}(#1,#2,#3,#4,#5)}